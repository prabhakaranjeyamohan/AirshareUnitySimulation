// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: IUX_submessages.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace IUX {

  /// <summary>Holder for reflection information generated from IUX_submessages.proto</summary>
  public static partial class IUXSubmessagesReflection {

    #region Descriptor
    /// <summary>File descriptor for IUX_submessages.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static IUXSubmessagesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVJVVhfc3VibWVzc2FnZXMucHJvdG8SA0lVWBoUSVVYX3N1YnN0cnVjdHMu",
            "cHJvdG8iMAoJUGxhaW5UZXh0EhUKDWRvd25zdHJlYW1faWQYASABKAcSDAoE",
            "dGV4dBgCIAEoDCIiCglCcm9hZGNhc3QSFQoNZG93bnN0cmVhbV9pZBgBIAEo",
            "DSI8Cg5Ccm9hZGNhc3RSZXBseRIVCg1kb3duc3RyZWFtX2lkGAEgASgNEhMK",
            "C3Vwc3RyZWFtX2lkGAIgASgNIo8BCgZMYXVuY2gSEgoKbWlzc2lsZV9pZBgB",
            "IAEoBxIvCg5mbGlnaHRfcHJvZmlsZRgCIAEoCzISLklVWC5GbGlnaHRQcm9m",
            "aWxlSACIAQESIgoGdGFyZ2V0GAMgASgLMg0uSVVYLkxvY2F0aW9uSAGIAQFC",
            "EQoPX2ZsaWdodF9wcm9maWxlQgkKB190YXJnZXQiRAoPVGFyZ2V0UG9zVXBk",
            "YXRlEhIKCm1pc3NpbGVfaWQYASABKAcSHQoGdGFyZ2V0GAIgASgLMg0uSVVY",
            "LkxvY2F0aW9uIpsBCgVBYm9ydBISCgptaXNzaWxlX2lkGAEgASgHEg4KBmRl",
            "cGxveRgCIAEoCBIqCgthY3Rpb25fY29kZRgDIAEoDjIVLklVWC5BYm9ydC5B",
            "Y3Rpb25Db2RlIkIKCkFjdGlvbkNvZGUSBwoDRU5EEAASCQoFRVJBU0UQARIN",
            "CglURVJNSU5BVEUQAhIRCg1TRUxGX0RFU1RSVUNUEAMijAEKA0FybRISCgpt",
            "aXNzaWxlX2lkGAEgASgHEi8KDmZsaWdodF9wcm9maWxlGAIgASgLMhIuSVVY",
            "LkZsaWdodFByb2ZpbGVIAIgBARIiCgZ0YXJnZXQYAyABKAsyDS5JVVguTG9j",
            "YXRpb25IAYgBAUIRCg9fZmxpZ2h0X3Byb2ZpbGVCCQoHX3RhcmdldCJUCgtT",
            "dGVlclVwZGF0ZRISCgptaXNzaWxlX2lkGAEgASgHEhEKCWVsZXZhdGlvbhgC",
            "IAEoAhIPCgdhemltdXRoGAMgASgCEg0KBXJhbmdlGAQgASgCIjYKElJlcXVl",
            "c3RDYWxpYnJhdGlvbhISCgptaXNzaWxlX2lkGAEgASgHEgwKBGtleXMYAiAD",
            "KAkieAoLQ2FsaWJyYXRpb24SEgoKbWlzc2lsZV9pZBgBIAEoBxIoCgRkYXRh",
            "GAIgAygLMhouSVVYLkNhbGlicmF0aW9uLkRhdGFFbnRyeRorCglEYXRhRW50",
            "cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgCOgI4ASL4AQoNUmVxdWVz",
            "dFN0YXR1cxISCgptaXNzaWxlX2lkGAEgASgHEhAKCGxhdGl0dWRlGAIgASgI",
            "EhEKCWxvbmdpdHVkZRgDIAEoCBIQCghhbHRpdHVkZRgEIAEoCBINCgVyYW5n",
            "ZRgFIAEoCBIZChF0aW1lX3RvX2ludGVyY2VwdBgGIAEoCBIMCgRyb2xsGAcg",
            "ASgIEg0KBXBpdGNoGAggASgIEgsKA3lhdxgJIAEoCBIOCgZzaWduYWwYCiAB",
            "KAgSDwoHc2Vuc29ycxgLIAEoCBIVCg1iYXR0ZXJ5X2xldmVsGAwgASgIEhAK",
            "CGdwc190aW1lGA0gASgEIu4ECgZTdGF0dXMSEgoKbWlzc2lsZV9pZBgBIAEo",
            "BxIkCgtzdGF0dXNfY29kZRgCIAEoDjIPLklVWC5TdGF0dXNDb2RlEhcKCmVy",
            "cm9yX2NvZGUYESABKA1IAIgBARIkCghwb3NpdGlvbhgDIAEoCzINLklVWC5M",
            "b2NhdGlvbkgBiAEBEhIKBXJhbmdlGAQgASgCSAKIAQESHgoRdGltZV90b19p",
            "bnRlcmNlcHQYBSABKAJIA4gBARIRCgRyb2xsGAYgASgCSASIAQESEgoFcGl0",
            "Y2gYByABKAJIBYgBARIQCgN5YXcYCCABKAJIBogBARITCgZzaWduYWwYCSAB",
            "KAJIB4gBARIWCglpbXVfc3RhdGUYCiABKAhICIgBARIWCglncHNfc3RhdGUY",
            "CyABKAhICYgBARIbCg5wcmVzc3VyZV9zdGF0ZRgMIAEoCEgKiAEBEhYKCW1h",
            "Z19zdGF0ZRgNIAEoCEgLiAEBEhoKDWJhdHRlcnlfbGV2ZWwYDiABKAJIDIgB",
            "ARImCgxibG9ja19jb25maWcYDyABKA4yEC5JVVguQmxvY2tDb25maWcSDwoH",
            "Z3BzdGltZRgQIAEoBEINCgtfZXJyb3JfY29kZUILCglfcG9zaXRpb25CCAoG",
            "X3JhbmdlQhQKEl90aW1lX3RvX2ludGVyY2VwdEIHCgVfcm9sbEIICgZfcGl0",
            "Y2hCBgoEX3lhd0IJCgdfc2lnbmFsQgwKCl9pbXVfc3RhdGVCDAoKX2dwc19z",
            "dGF0ZUIRCg9fcHJlc3N1cmVfc3RhdGVCDAoKX21hZ19zdGF0ZUIQCg5fYmF0",
            "dGVyeV9sZXZlbCKtAQoIVHJhY2tpbmcSEgoKbWlzc2lsZV9pZBgBIAEoBxIZ",
            "ChFiZWFyaW5nX3RvX3RhcmdldBgCIAEoAhIdChVkaXN0YW5jZV90b19pbnRl",
            "cmNlcHQYAyABKAISGQoRdGltZV90b19pbnRlcmNlcHQYBCABKAISEAoIdmVs",
            "b2NpdHkYBSABKAISJgoMdGFyZ2V0X2NsYXNzGAYgASgOMhAuSVVYLlRhcmdl",
            "dENsYXNzIhwKBkRpc2FybRISCgptaXNzaWxlX2lkGAEgASgHIjQKBVJlc2V0",
            "EhIKCm1pc3NpbGVfaWQYASABKAcSFwoPYmFzZV9zdGF0aW9uX2lkGAIgASgH",
            "Is0BChFSYWlsU3RhdHVzUmVxdWVzdBIXCg9iYXNlX3N0YXRpb25faWQYASAB",
            "KAcSEAoIcG9zaXRpb24YAiABKAgSEAoIYXR0aXR1ZGUYAyABKAgSDgoGc2ln",
            "bmFsGAQgASgIEhYKDm1pc3NpbGVfc3RhdGVzGAUgASgIEhMKC3JhaWxfc3Rh",
            "dGVzGAYgASgIEhQKDGJsb2NrX2NvbmZpZxgHIAEoCBIWCg5iYXR0ZXJ5X2xl",
            "dmVscxgIIAEoCBIQCghncHNfdGltZRgJIAEoBCKuAgoKUmFpbFN0YXR1cxIX",
            "Cg9iYXNlX3N0YXRpb25faWQYASABKAcSEgoKbWlzc2lsZV9pZBgCIAMoBxIf",
            "Cghwb3NpdGlvbhgDIAMoCzINLklVWC5Mb2NhdGlvbhIfCghhdHRpdHVkZRgE",
            "IAMoCzINLklVWC5BdHRpdHVkZRIOCgZzaWduYWwYBSADKAISJwoObWlzc2ls",
            "ZV9zdGF0ZXMYBiADKA4yDy5JVVguU3RhdHVzQ29kZRIkCgtyYWlsX3N0YXRl",
            "cxgHIAMoDjIPLklVWC5TdGF0dXNDb2RlEiYKDGJsb2NrX2NvbmZpZxgIIAMo",
            "DjIQLklVWC5CbG9ja0NvbmZpZxIWCg5iYXR0ZXJ5X2xldmVscxgJIAMoAhIS",
            "CgplcnJvcl9jb2RlGAogAygNIksKEVR1cnJldEN1ZVRvVGFyZ2V0EhcKD2Jh",
            "c2Vfc3RhdGlvbl9pZBgBIAEoBxIdCgZ0YXJnZXQYAiABKAsyDS5JVVguTG9j",
            "YXRpb24ixAMKD1R1cnJldENhbGlicmF0ZRIXCg9iYXNlX3N0YXRpb25faWQY",
            "ASABKAcSNAoIbW92ZW1lbnQYAiABKA4yHS5JVVguVHVycmV0Q2FsaWJyYXRl",
            "Lk1vdmVtZW50SACIAQESRwoSbW92ZW1lbnRfZGlyZWN0aW9uGAMgASgOMiYu",
            "SVVYLlR1cnJldENhbGlicmF0ZS5Nb3ZlbWVudERpcmVjdGlvbkgBiAEBEhYK",
            "CXN0ZXBfc2l6ZRgEIAEoAkgCiAEBEhYKCWVsZXZhdGlvbhgFIAEoAkgDiAEB",
            "EhQKB2F6aW11dGgYBiABKAJIBIgBARIWCg5hdXRvX2NhbGlicmF0ZRgHIAEo",
            "CCInCghNb3ZlbWVudBILCgdTVEVQUEVEEAASDgoKQ09OVElOVU9VUxABIkYK",
            "EU1vdmVtZW50RGlyZWN0aW9uEgoKBkNBTkNFTBAAEggKBExFRlQQARIGCgJV",
            "UBACEgkKBVJJR0hUEAMSCAoERE9XThAEQgsKCV9tb3ZlbWVudEIVChNfbW92",
            "ZW1lbnRfZGlyZWN0aW9uQgwKCl9zdGVwX3NpemVCDAoKX2VsZXZhdGlvbkIK",
            "CghfYXppbXV0aCIuChNUdXJyZXRFbWVyZ2VuY3lTdG9wEhcKD2Jhc2Vfc3Rh",
            "dGlvbl9pZBgBIAEoByJFCgtUdXJyZXRUcmFjaxIXCg9iYXNlX3N0YXRpb25f",
            "aWQYASABKAcSHQoGdGFyZ2V0GAIgASgLMg0uSVVYLkxvY2F0aW9uInwKE1R1",
            "cnJldFN0YXR1c1JlcXVlc3QSFwoPYmFzZV9zdGF0aW9uX2lkGAEgASgHEhAK",
            "CHBvc2l0aW9uGAIgASgIEhAKCGR5bmFtaWNzGAMgASgIEhAKCGF0dGl0dWRl",
            "GAQgASgIEhYKDmJzc19jb25uZWN0aW9uGAUgASgIIt0DCgxUdXJyZXRTdGF0",
            "dXMSFwoPYmFzZV9zdGF0aW9uX2lkGAEgASgHEiQKCHBvc2l0aW9uGAIgASgL",
            "Mg0uSVVYLkxvY2F0aW9uSACIAQESIgoIdmVsb2NpdHkYAyABKAsyCy5JVVgu",
            "UG9pbnQzSAGIAQESJgoMYWNjZWxlcmF0aW9uGAQgASgLMgsuSVVYLlBvaW50",
            "M0gCiAEBEhsKDmF0dGl0dWRlX3ZhbGlkGAUgASgISAOIAQESIwoHY3VycmVu",
            "dBgGIAEoCzINLklVWC5BdHRpdHVkZUgEiAEBEiIKBnRhcmdldBgHIAEoCzIN",
            "LklVWC5BdHRpdHVkZUgFiAEBEhMKBm1vdmluZxgIIAEoCEgGiAEBEiwKDmJz",
            "c19jb25uZWN0aW9uGAkgASgOMg8uSVVYLlN0YXR1c0NvZGVIB4gBARIXCgpl",
            "cnJvcl9jb2RlGAogASgNSAiIAQFCCwoJX3Bvc2l0aW9uQgsKCV92ZWxvY2l0",
            "eUIPCg1fYWNjZWxlcmF0aW9uQhEKD19hdHRpdHVkZV92YWxpZEIKCghfY3Vy",
            "cmVudEIJCgdfdGFyZ2V0QgkKB19tb3ZpbmdCEQoPX2Jzc19jb25uZWN0aW9u",
            "Qg0KC19lcnJvcl9jb2RlIsYBCg1SZWFkeVRvTGF1bmNoEhIKCm1pc3NpbGVf",
            "aWQYASABKAcSLwoOZmxpZ2h0X3Byb2ZpbGUYAiABKAsyEi5JVVguRmxpZ2h0",
            "UHJvZmlsZUgAiAEBEiIKBnRhcmdldBgDIAEoCzINLklVWC5Mb2NhdGlvbkgB",
            "iAEBEhsKDmludGVyY2VwdF90aW1lGAQgASgNSAKIAQFCEQoPX2ZsaWdodF9w",
            "cm9maWxlQgkKB190YXJnZXRCEQoPX2ludGVyY2VwdF90aW1lIukBCgdBcm1S",
            "YWlsEhcKD2Jhc2Vfc3RhdGlvbl9pZBgBIAEoBxIMCgRyYWlsGAIgASgNEhQK",
            "DHR1cnJldF90cmFjaxgDIAEoCBIvCg5mbGlnaHRfcHJvZmlsZRgEIAEoCzIS",
            "LklVWC5GbGlnaHRQcm9maWxlSACIAQESIgoGdGFyZ2V0GAUgASgLMg0uSVVY",
            "LkxvY2F0aW9uSAGIAQESGwoOaW50ZXJjZXB0X3RpbWUYBiABKA1IAogBAUIR",
            "Cg9fZmxpZ2h0X3Byb2ZpbGVCCQoHX3RhcmdldEIRCg9faW50ZXJjZXB0X3Rp",
            "bWUiMwoKRGlzYXJtUmFpbBIXCg9iYXNlX3N0YXRpb25faWQYASABKAcSDAoE",
            "cmFpbBgCIAEoDSKrAwoKTGF1bmNoUmFpbBIXCg9iYXNlX3N0YXRpb25faWQY",
            "ASABKAcSEQoEcmFpbBgCIAEoDUgAiAEBEjUKDmxhdW5jaF9wYXR0ZXJuGAMg",
            "ASgOMh0uSVVYLkxhdW5jaFJhaWwuTGF1bmNoUGF0dGVybhISCgVkZWxheRgE",
            "IAEoAkgBiAEBEhQKDHR1cnJldF90cmFjaxgFIAEoCBIvCg5mbGlnaHRfcHJv",
            "ZmlsZRgGIAEoCzISLklVWC5GbGlnaHRQcm9maWxlSAKIAQESIgoGdGFyZ2V0",
            "GAcgASgLMg0uSVVYLkxvY2F0aW9uSAOIAQESGwoOaW50ZXJjZXB0X3RpbWUY",
            "CCABKA1IBIgBASJaCg1MYXVuY2hQYXR0ZXJuEgoKBk5PUk1BTBAAEhQKEEFS",
            "TUVEX1NFUVVFTlRJQUwQARIWChJBUk1FRF9TSU1VTFRBTkVPVVMQAhIPCgtB",
            "Uk1FRF9ERUxBWRADQgcKBV9yYWlsQggKBl9kZWxheUIRCg9fZmxpZ2h0X3By",
            "b2ZpbGVCCQoHX3RhcmdldEIRCg9faW50ZXJjZXB0X3RpbWUiNgoNTWlzc2ls",
            "ZUxvYWRlZBIXCg9iYXNlX3N0YXRpb25faWQYASABKAcSDAoEcmFpbBgCIAEo",
            "DSI4Cg9NaXNzaWxlVW5sb2FkZWQSFwoPYmFzZV9zdGF0aW9uX2lkGAEgASgH",
            "EgwKBHJhaWwYAiABKA0iwwEKC1R1cnJldFJlc2V0EhcKD2Jhc2Vfc3RhdGlv",
            "bl9pZBgBIAEoBxIuCgpyZXNldF9tb2RlGAIgASgOMhouSVVYLlR1cnJldFJl",
            "c2V0LlJlc2V0TW9kZRIRCgRyYWlsGAMgASgNSACIAQESEQoEYmFuaxgEIAEo",
            "DUgBiAEBIjMKCVJlc2V0TW9kZRIHCgNBTEwQABIICgRSQUlMEAESCAoEQkFO",
            "SxACEgkKBVJGOTE1EANCBwoFX3JhaWxCBwoFX2JhbmsihgUKCkJTU1JlcXVl",
            "c3QSCgoCaWQYASABKA0SIgoNYmFzZV9wb3NpdGlvbhgCIAEoCzILLklVWC5Q",
            "b2ludDMSIgoNYmFzZV92ZWxvY2l0eRgDIAEoCzILLklVWC5Qb2ludDMSJgoR",
            "YmFzZV9hY2NlbGVyYXRpb24YBCABKAsyCy5JVVguUG9pbnQzEiQKD3Rhcmdl",
            "dF9wb3NpdGlvbhgFIAEoCzILLklVWC5Qb2ludDMSJAoPdGFyZ2V0X3ZlbG9j",
            "aXR5GAYgASgLMgsuSVVYLlBvaW50MxIoChN0YXJnZXRfYWNjZWxlcmF0aW9u",
            "GAcgASgLMgsuSVVYLlBvaW50MxITCgtmbGlnaHRfdGltZRgIIAEoAhISCgpn",
            "ZXRfc3RhdHVzGAkgASgIEhkKEWdldF9pbnRlcmNlcHRfRU5VGAogASgIEhoK",
            "EmdldF9pbnRlcmNlcHRfRUNFRhgLIAEoCBIZChFnZXRfaW50ZXJjZXB0X0dF",
            "TxgMIAEoCBIZChFnZXRfbGF1bmNoX2FuZ2xlcxgNIAEoCBIWCg5yZXR1cm5f",
            "YWRkcmVzcxgOIAEoDRITCgtyZXR1cm5fcG9ydBgPIAEoDRIfChdyZXBseV93",
            "aXRoX3R1cnJldF90cmFjaxgQIAEoCBIsCh90dXJyZXRfdHJhY2tfZG93bnN0",
            "cmVhbV9hZGRyZXNzGBEgASgHSACIAQESLgoUbWlzc2lsZV9ibG9ja19jb25m",
            "aWcYEiABKA4yEC5JVVguQmxvY2tDb25maWcSIAoYZ2V0X21pc3NpbGVfcG9z",
            "aXRpb25fRU5VGBMgASgIQiIKIF90dXJyZXRfdHJhY2tfZG93bnN0cmVhbV9h",
            "ZGRyZXNzIqwECghCU1NSZXBseRIKCgJpZBgBIAEoDRIkCgZzdGF0dXMYAiAB",
            "KA4yDy5JVVguU3RhdHVzQ29kZUgAiAEBEicKDWludGVyY2VwdF9FTlUYAyAB",
            "KAsyCy5JVVguUG9pbnQzSAGIAQESKAoOaW50ZXJjZXB0X0VDRUYYBCABKAsy",
            "Cy5JVVguUG9pbnQzSAKIAQESGgoNaW50ZXJjZXB0X2xhdBgFIAEoAkgDiAEB",
            "EhoKDWludGVyY2VwdF9sb24YBiABKAJIBIgBARIaCg1pbnRlcmNlcHRfYWx0",
            "GAcgASgCSAWIAQESHgoRdGltZV90b19pbnRlcmNlcHQYCCABKAJIBogBARId",
            "ChBsYXVuY2hfZWxldmF0aW9uGAkgASgCSAeIAQESGwoObGF1bmNoX2F6aW11",
            "dGgYCiABKAJICIgBARIuChRtaXNzaWxlX3Bvc2l0aW9uX0VOVRgLIAEoCzIL",
            "LklVWC5Qb2ludDNICYgBAUIJCgdfc3RhdHVzQhAKDl9pbnRlcmNlcHRfRU5V",
            "QhEKD19pbnRlcmNlcHRfRUNFRkIQCg5faW50ZXJjZXB0X2xhdEIQCg5faW50",
            "ZXJjZXB0X2xvbkIQCg5faW50ZXJjZXB0X2FsdEIUChJfdGltZV90b19pbnRl",
            "cmNlcHRCEwoRX2xhdW5jaF9lbGV2YXRpb25CEQoPX2xhdW5jaF9hemltdXRo",
            "QhcKFV9taXNzaWxlX3Bvc2l0aW9uX0VOVUIrChBjb20uYWlyc2hhcmUuaXV4",
            "Qg9JVVhfc3VibWVzc2FnZXNIAaICA0lVWFAAYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::IUX.IUXSubstructsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.PlainText), global::IUX.PlainText.Parser, new[]{ "DownstreamId", "Text" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Broadcast), global::IUX.Broadcast.Parser, new[]{ "DownstreamId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.BroadcastReply), global::IUX.BroadcastReply.Parser, new[]{ "DownstreamId", "UpstreamId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Launch), global::IUX.Launch.Parser, new[]{ "MissileId", "FlightProfile", "Target" }, new[]{ "FlightProfile", "Target" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TargetPosUpdate), global::IUX.TargetPosUpdate.Parser, new[]{ "MissileId", "Target" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Abort), global::IUX.Abort.Parser, new[]{ "MissileId", "Deploy", "ActionCode" }, null, new[]{ typeof(global::IUX.Abort.Types.ActionCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Arm), global::IUX.Arm.Parser, new[]{ "MissileId", "FlightProfile", "Target" }, new[]{ "FlightProfile", "Target" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.SteerUpdate), global::IUX.SteerUpdate.Parser, new[]{ "MissileId", "Elevation", "Azimuth", "Range" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.RequestCalibration), global::IUX.RequestCalibration.Parser, new[]{ "MissileId", "Keys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Calibration), global::IUX.Calibration.Parser, new[]{ "MissileId", "Data" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.RequestStatus), global::IUX.RequestStatus.Parser, new[]{ "MissileId", "Latitude", "Longitude", "Altitude", "Range", "TimeToIntercept", "Roll", "Pitch", "Yaw", "Signal", "Sensors", "BatteryLevel", "GpsTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Status), global::IUX.Status.Parser, new[]{ "MissileId", "StatusCode", "ErrorCode", "Position", "Range", "TimeToIntercept", "Roll", "Pitch", "Yaw", "Signal", "ImuState", "GpsState", "PressureState", "MagState", "BatteryLevel", "BlockConfig", "Gpstime" }, new[]{ "ErrorCode", "Position", "Range", "TimeToIntercept", "Roll", "Pitch", "Yaw", "Signal", "ImuState", "GpsState", "PressureState", "MagState", "BatteryLevel" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Tracking), global::IUX.Tracking.Parser, new[]{ "MissileId", "BearingToTarget", "DistanceToIntercept", "TimeToIntercept", "Velocity", "TargetClass" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Disarm), global::IUX.Disarm.Parser, new[]{ "MissileId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.Reset), global::IUX.Reset.Parser, new[]{ "MissileId", "BaseStationId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.RailStatusRequest), global::IUX.RailStatusRequest.Parser, new[]{ "BaseStationId", "Position", "Attitude", "Signal", "MissileStates", "RailStates", "BlockConfig", "BatteryLevels", "GpsTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.RailStatus), global::IUX.RailStatus.Parser, new[]{ "BaseStationId", "MissileId", "Position", "Attitude", "Signal", "MissileStates", "RailStates", "BlockConfig", "BatteryLevels", "ErrorCode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretCueToTarget), global::IUX.TurretCueToTarget.Parser, new[]{ "BaseStationId", "Target" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretCalibrate), global::IUX.TurretCalibrate.Parser, new[]{ "BaseStationId", "Movement", "MovementDirection", "StepSize", "Elevation", "Azimuth", "AutoCalibrate" }, new[]{ "Movement", "MovementDirection", "StepSize", "Elevation", "Azimuth" }, new[]{ typeof(global::IUX.TurretCalibrate.Types.Movement), typeof(global::IUX.TurretCalibrate.Types.MovementDirection) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretEmergencyStop), global::IUX.TurretEmergencyStop.Parser, new[]{ "BaseStationId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretTrack), global::IUX.TurretTrack.Parser, new[]{ "BaseStationId", "Target" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretStatusRequest), global::IUX.TurretStatusRequest.Parser, new[]{ "BaseStationId", "Position", "Dynamics", "Attitude", "BssConnection" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretStatus), global::IUX.TurretStatus.Parser, new[]{ "BaseStationId", "Position", "Velocity", "Acceleration", "AttitudeValid", "Current", "Target", "Moving", "BssConnection", "ErrorCode" }, new[]{ "Position", "Velocity", "Acceleration", "AttitudeValid", "Current", "Target", "Moving", "BssConnection", "ErrorCode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.ReadyToLaunch), global::IUX.ReadyToLaunch.Parser, new[]{ "MissileId", "FlightProfile", "Target", "InterceptTime" }, new[]{ "FlightProfile", "Target", "InterceptTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.ArmRail), global::IUX.ArmRail.Parser, new[]{ "BaseStationId", "Rail", "TurretTrack", "FlightProfile", "Target", "InterceptTime" }, new[]{ "FlightProfile", "Target", "InterceptTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.DisarmRail), global::IUX.DisarmRail.Parser, new[]{ "BaseStationId", "Rail" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.LaunchRail), global::IUX.LaunchRail.Parser, new[]{ "BaseStationId", "Rail", "LaunchPattern", "Delay", "TurretTrack", "FlightProfile", "Target", "InterceptTime" }, new[]{ "Rail", "Delay", "FlightProfile", "Target", "InterceptTime" }, new[]{ typeof(global::IUX.LaunchRail.Types.LaunchPattern) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.MissileLoaded), global::IUX.MissileLoaded.Parser, new[]{ "BaseStationId", "Rail" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.MissileUnloaded), global::IUX.MissileUnloaded.Parser, new[]{ "BaseStationId", "Rail" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.TurretReset), global::IUX.TurretReset.Parser, new[]{ "BaseStationId", "ResetMode", "Rail", "Bank" }, new[]{ "Rail", "Bank" }, new[]{ typeof(global::IUX.TurretReset.Types.ResetMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.BSSRequest), global::IUX.BSSRequest.Parser, new[]{ "Id", "BasePosition", "BaseVelocity", "BaseAcceleration", "TargetPosition", "TargetVelocity", "TargetAcceleration", "FlightTime", "GetStatus", "GetInterceptENU", "GetInterceptECEF", "GetInterceptGEO", "GetLaunchAngles", "ReturnAddress", "ReturnPort", "ReplyWithTurretTrack", "TurretTrackDownstreamAddress", "MissileBlockConfig", "GetMissilePositionENU" }, new[]{ "TurretTrackDownstreamAddress" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::IUX.BSSReply), global::IUX.BSSReply.Parser, new[]{ "Id", "Status", "InterceptENU", "InterceptECEF", "InterceptLat", "InterceptLon", "InterceptAlt", "TimeToIntercept", "LaunchElevation", "LaunchAzimuth", "MissilePositionENU" }, new[]{ "Status", "InterceptENU", "InterceptECEF", "InterceptLat", "InterceptLon", "InterceptAlt", "TimeToIntercept", "LaunchElevation", "LaunchAzimuth", "MissilePositionENU" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Primarily used for debugging. Not very useful for most tasks.
  /// </summary>
  public sealed partial class PlainText : pb::IMessage<PlainText>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PlainText> _parser = new pb::MessageParser<PlainText>(() => new PlainText());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PlainText> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlainText() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlainText(PlainText other) : this() {
      downstreamId_ = other.downstreamId_;
      text_ = other.text_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlainText Clone() {
      return new PlainText(this);
    }

    /// <summary>Field number for the "downstream_id" field.</summary>
    public const int DownstreamIdFieldNumber = 1;
    private uint downstreamId_;
    /// <summary>
    /// The ID of the sending device
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DownstreamId {
      get { return downstreamId_; }
      set {
        downstreamId_ = value;
      }
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 2;
    private pb::ByteString text_ = pb::ByteString.Empty;
    /// <summary>
    /// The plaintext message (limited to 512 bytes on embedded, message dicarded when exceeded)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Text {
      get { return text_; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PlainText);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PlainText other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DownstreamId != other.DownstreamId) return false;
      if (Text != other.Text) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DownstreamId != 0) hash ^= DownstreamId.GetHashCode();
      if (Text.Length != 0) hash ^= Text.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (DownstreamId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(DownstreamId);
      }
      if (Text.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Text);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (DownstreamId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(DownstreamId);
      }
      if (Text.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Text);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DownstreamId != 0) {
        size += 1 + 4;
      }
      if (Text.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Text);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PlainText other) {
      if (other == null) {
        return;
      }
      if (other.DownstreamId != 0) {
        DownstreamId = other.DownstreamId;
      }
      if (other.Text.Length != 0) {
        Text = other.Text;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            DownstreamId = input.ReadFixed32();
            break;
          }
          case 18: {
            Text = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            DownstreamId = input.ReadFixed32();
            break;
          }
          case 18: {
            Text = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// This message is used for connected to upstream controller systems.  
  /// Ex. BSC --broadcast--> BSS
  /// Ex. BSC --broadcast--> ASSURE
  /// Ex. ASSURE --broadcast--> BSS
  ///
  /// Expects a reply of [BroadcastReply](#IUX.BroadcastReply)
  /// </summary>
  public sealed partial class Broadcast : pb::IMessage<Broadcast>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Broadcast> _parser = new pb::MessageParser<Broadcast>(() => new Broadcast());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Broadcast> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Broadcast() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Broadcast(Broadcast other) : this() {
      downstreamId_ = other.downstreamId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Broadcast Clone() {
      return new Broadcast(this);
    }

    /// <summary>Field number for the "downstream_id" field.</summary>
    public const int DownstreamIdFieldNumber = 1;
    private uint downstreamId_;
    /// <summary>
    /// The ID of the downstream (sending) device
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DownstreamId {
      get { return downstreamId_; }
      set {
        downstreamId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Broadcast);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Broadcast other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DownstreamId != other.DownstreamId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DownstreamId != 0) hash ^= DownstreamId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (DownstreamId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(DownstreamId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (DownstreamId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(DownstreamId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DownstreamId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DownstreamId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Broadcast other) {
      if (other == null) {
        return;
      }
      if (other.DownstreamId != 0) {
        DownstreamId = other.DownstreamId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DownstreamId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            DownstreamId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// The upstream reply to a [Broadcast](#IUX.Broadcast) message.  
  /// This message tells the downstream device that it exists and that it wants to connect.
  /// </summary>
  public sealed partial class BroadcastReply : pb::IMessage<BroadcastReply>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BroadcastReply> _parser = new pb::MessageParser<BroadcastReply>(() => new BroadcastReply());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BroadcastReply> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BroadcastReply() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BroadcastReply(BroadcastReply other) : this() {
      downstreamId_ = other.downstreamId_;
      upstreamId_ = other.upstreamId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BroadcastReply Clone() {
      return new BroadcastReply(this);
    }

    /// <summary>Field number for the "downstream_id" field.</summary>
    public const int DownstreamIdFieldNumber = 1;
    private uint downstreamId_;
    /// <summary>
    /// The ID of the downstream (receiving) device, Should be the same as downstream in [Broadcast](#IUX.Broadcast)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DownstreamId {
      get { return downstreamId_; }
      set {
        downstreamId_ = value;
      }
    }

    /// <summary>Field number for the "upstream_id" field.</summary>
    public const int UpstreamIdFieldNumber = 2;
    private uint upstreamId_;
    /// <summary>
    /// The ID of the upstrea (sending) device, Can be checked by the downstream device for ID validation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint UpstreamId {
      get { return upstreamId_; }
      set {
        upstreamId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BroadcastReply);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BroadcastReply other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DownstreamId != other.DownstreamId) return false;
      if (UpstreamId != other.UpstreamId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DownstreamId != 0) hash ^= DownstreamId.GetHashCode();
      if (UpstreamId != 0) hash ^= UpstreamId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (DownstreamId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(DownstreamId);
      }
      if (UpstreamId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(UpstreamId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (DownstreamId != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(DownstreamId);
      }
      if (UpstreamId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(UpstreamId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DownstreamId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DownstreamId);
      }
      if (UpstreamId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UpstreamId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BroadcastReply other) {
      if (other == null) {
        return;
      }
      if (other.DownstreamId != 0) {
        DownstreamId = other.DownstreamId;
      }
      if (other.UpstreamId != 0) {
        UpstreamId = other.UpstreamId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DownstreamId = input.ReadUInt32();
            break;
          }
          case 16: {
            UpstreamId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            DownstreamId = input.ReadUInt32();
            break;
          }
          case 16: {
            UpstreamId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for launching.  
  /// This message should trigger a launch on a missile.
  /// </summary>
  public sealed partial class Launch : pb::IMessage<Launch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Launch> _parser = new pb::MessageParser<Launch>(() => new Launch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Launch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Launch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Launch(Launch other) : this() {
      missileId_ = other.missileId_;
      flightProfile_ = other.flightProfile_ != null ? other.flightProfile_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Launch Clone() {
      return new Launch(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "flight_profile" field.</summary>
    public const int FlightProfileFieldNumber = 2;
    private global::IUX.FlightProfile flightProfile_;
    /// <summary>
    /// The Flight Profile to use for the missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.FlightProfile FlightProfile {
      get { return flightProfile_; }
      set {
        flightProfile_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 3;
    private global::IUX.Location target_;
    /// <summary>
    /// The Location of the missiles Target. Used for activate flight-control missiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Launch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Launch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!object.Equals(FlightProfile, other.FlightProfile)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (flightProfile_ != null) hash ^= FlightProfile.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (flightProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlightProfile);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Launch other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.flightProfile_ != null) {
        if (flightProfile_ == null) {
          FlightProfile = new global::IUX.FlightProfile();
        }
        FlightProfile.MergeFrom(other.FlightProfile);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for updating the location of a target during flight are while on the launch rail.  
  /// This message just updates the target location information on the missile
  /// </summary>
  public sealed partial class TargetPosUpdate : pb::IMessage<TargetPosUpdate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TargetPosUpdate> _parser = new pb::MessageParser<TargetPosUpdate>(() => new TargetPosUpdate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TargetPosUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TargetPosUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TargetPosUpdate(TargetPosUpdate other) : this() {
      missileId_ = other.missileId_;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TargetPosUpdate Clone() {
      return new TargetPosUpdate(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 2;
    private global::IUX.Location target_;
    /// <summary>
    /// The updated location data of the target
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TargetPosUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TargetPosUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TargetPosUpdate other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for forcing an abort of a missile during flight.  
  /// This message may be handled differently on each missile, But it _should_ prevent
  /// deployment and is expected to alter guidance.  
  /// The effects are different based on the missile and the parameters passed.
  /// </summary>
  public sealed partial class Abort : pb::IMessage<Abort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Abort> _parser = new pb::MessageParser<Abort>(() => new Abort());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Abort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Abort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Abort(Abort other) : this() {
      missileId_ = other.missileId_;
      deploy_ = other.deploy_;
      actionCode_ = other.actionCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Abort Clone() {
      return new Abort(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "deploy" field.</summary>
    public const int DeployFieldNumber = 2;
    private bool deploy_;
    /// <summary>
    /// Control boolean for whether to deploy the countermeasures on abort (defaults to false)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Deploy {
      get { return deploy_; }
      set {
        deploy_ = value;
      }
    }

    /// <summary>Field number for the "action_code" field.</summary>
    public const int ActionCodeFieldNumber = 3;
    private global::IUX.Abort.Types.ActionCode actionCode_ = global::IUX.Abort.Types.ActionCode.End;
    /// <summary>
    /// The action code for abort
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Abort.Types.ActionCode ActionCode {
      get { return actionCode_; }
      set {
        actionCode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Abort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Abort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (Deploy != other.Deploy) return false;
      if (ActionCode != other.ActionCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (Deploy != false) hash ^= Deploy.GetHashCode();
      if (ActionCode != global::IUX.Abort.Types.ActionCode.End) hash ^= ActionCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Deploy != false) {
        output.WriteRawTag(16);
        output.WriteBool(Deploy);
      }
      if (ActionCode != global::IUX.Abort.Types.ActionCode.End) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ActionCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Deploy != false) {
        output.WriteRawTag(16);
        output.WriteBool(Deploy);
      }
      if (ActionCode != global::IUX.Abort.Types.ActionCode.End) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ActionCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (Deploy != false) {
        size += 1 + 1;
      }
      if (ActionCode != global::IUX.Abort.Types.ActionCode.End) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ActionCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Abort other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.Deploy != false) {
        Deploy = other.Deploy;
      }
      if (other.ActionCode != global::IUX.Abort.Types.ActionCode.End) {
        ActionCode = other.ActionCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            Deploy = input.ReadBool();
            break;
          }
          case 24: {
            ActionCode = (global::IUX.Abort.Types.ActionCode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            Deploy = input.ReadBool();
            break;
          }
          case 24: {
            ActionCode = (global::IUX.Abort.Types.ActionCode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Abort message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///*
      /// Abort actions
      /// Actions to be executed for the abort
      /// </summary>
      public enum ActionCode {
        /// <summary>
        /// Do nothing, Just abort (default)
        /// </summary>
        [pbr::OriginalName("END")] End = 0,
        /// <summary>
        /// Erase the flight computer and nullify the flight code
        /// </summary>
        [pbr::OriginalName("ERASE")] Erase = 1,
        /// <summary>
        /// ? Terminate
        /// </summary>
        [pbr::OriginalName("TERMINATE")] Terminate = 2,
        /// <summary>
        /// Physically destroy the flight computer and other missile hardware
        /// </summary>
        [pbr::OriginalName("SELF_DESTRUCT")] SelfDestruct = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///*
  /// Missile control messsage for arming a missile before launch.  
  /// This message should universally arm a missile and prepare it for launch, Including battery
  /// circuits, targeting computers, sensor wakeup, etc.
  /// </summary>
  public sealed partial class Arm : pb::IMessage<Arm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Arm> _parser = new pb::MessageParser<Arm>(() => new Arm());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Arm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Arm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Arm(Arm other) : this() {
      missileId_ = other.missileId_;
      flightProfile_ = other.flightProfile_ != null ? other.flightProfile_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Arm Clone() {
      return new Arm(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "flight_profile" field.</summary>
    public const int FlightProfileFieldNumber = 2;
    private global::IUX.FlightProfile flightProfile_;
    /// <summary>
    /// The Flight Profile to use for the missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.FlightProfile FlightProfile {
      get { return flightProfile_; }
      set {
        flightProfile_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 3;
    private global::IUX.Location target_;
    /// <summary>
    /// The Location of the missiles Target. Used for activate flight-control missiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Arm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Arm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!object.Equals(FlightProfile, other.FlightProfile)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (flightProfile_ != null) hash ^= FlightProfile.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (flightProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlightProfile);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Arm other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.flightProfile_ != null) {
        if (flightProfile_ == null) {
          FlightProfile = new global::IUX.FlightProfile();
        }
        FlightProfile.MergeFrom(other.FlightProfile);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for low level missile control.  
  /// This message is mostly deprecated and unused (Not used in new IUX)
  /// </summary>
  public sealed partial class SteerUpdate : pb::IMessage<SteerUpdate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SteerUpdate> _parser = new pb::MessageParser<SteerUpdate>(() => new SteerUpdate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SteerUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SteerUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SteerUpdate(SteerUpdate other) : this() {
      missileId_ = other.missileId_;
      elevation_ = other.elevation_;
      azimuth_ = other.azimuth_;
      range_ = other.range_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SteerUpdate Clone() {
      return new SteerUpdate(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "elevation" field.</summary>
    public const int ElevationFieldNumber = 2;
    private float elevation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Elevation {
      get { return elevation_; }
      set {
        elevation_ = value;
      }
    }

    /// <summary>Field number for the "azimuth" field.</summary>
    public const int AzimuthFieldNumber = 3;
    private float azimuth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Azimuth {
      get { return azimuth_; }
      set {
        azimuth_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 4;
    private float range_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SteerUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SteerUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Elevation, other.Elevation)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Azimuth, other.Azimuth)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Range, other.Range)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (Elevation != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Elevation);
      if (Azimuth != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Azimuth);
      if (Range != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Range);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Elevation != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Elevation);
      }
      if (Azimuth != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Azimuth);
      }
      if (Range != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Range);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Elevation != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Elevation);
      }
      if (Azimuth != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Azimuth);
      }
      if (Range != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Range);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (Elevation != 0F) {
        size += 1 + 4;
      }
      if (Azimuth != 0F) {
        size += 1 + 4;
      }
      if (Range != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SteerUpdate other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.Elevation != 0F) {
        Elevation = other.Elevation;
      }
      if (other.Azimuth != 0F) {
        Azimuth = other.Azimuth;
      }
      if (other.Range != 0F) {
        Range = other.Range;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            Elevation = input.ReadFloat();
            break;
          }
          case 29: {
            Azimuth = input.ReadFloat();
            break;
          }
          case 37: {
            Range = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            Elevation = input.ReadFloat();
            break;
          }
          case 29: {
            Azimuth = input.ReadFloat();
            break;
          }
          case 37: {
            Range = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile request to upstream device to provide calibration information.  
  /// Requests a mapped set of configuration parameters. Message is intended to be open-ended for device-specific implementation.  
  /// Expects a [Calibration](#IUX.Calibration) reply.  
  /// Currently unused.
  /// </summary>
  public sealed partial class RequestCalibration : pb::IMessage<RequestCalibration>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RequestCalibration> _parser = new pb::MessageParser<RequestCalibration>(() => new RequestCalibration());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RequestCalibration> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestCalibration() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestCalibration(RequestCalibration other) : this() {
      missileId_ = other.missileId_;
      keys_ = other.keys_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestCalibration Clone() {
      return new RequestCalibration(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile (sender) requesting the calibration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_keys_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of keys for which to get calibration data for
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Keys {
      get { return keys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RequestCalibration);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RequestCalibration other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if(!keys_.Equals(other.keys_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      hash ^= keys_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      keys_.WriteTo(output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      keys_.WriteTo(ref output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RequestCalibration other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      keys_.Add(other.keys_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///* 
  /// Missile configuration message with keyed calibration data.  
  /// Sent either un-prompted or as a reply to a [RequestCalibration](#IUX.RequestCalibration) message.  
  /// Current unused.
  /// </summary>
  public sealed partial class Calibration : pb::IMessage<Calibration>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Calibration> _parser = new pb::MessageParser<Calibration>(() => new Calibration());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Calibration> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Calibration() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Calibration(Calibration other) : this() {
      missileId_ = other.missileId_;
      data_ = other.data_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Calibration Clone() {
      return new Calibration(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 2;
    private static readonly pbc::MapField<string, float>.Codec _map_data_codec
        = new pbc::MapField<string, float>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForFloat(21, 0F), 18);
    private readonly pbc::MapField<string, float> data_ = new pbc::MapField<string, float>();
    /// <summary>
    /// Data map of keys and values for calibration and configuration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, float> Data {
      get { return data_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Calibration);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Calibration other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!Data.Equals(other.Data)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      hash ^= Data.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      data_.WriteTo(output, _map_data_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      data_.WriteTo(ref output, _map_data_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      size += data_.CalculateSize(_map_data_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Calibration other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      data_.Add(other.data_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            data_.AddEntriesFrom(input, _map_data_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            data_.AddEntriesFrom(ref input, _map_data_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for requesting a [Status](#IUX.Status) message.  
  /// A [Status](#IUX.Status) reply is always expected if the Missile is connected.  
  /// This message carries a set of booleans, each specifying a type of data to request from the missile.  
  /// The Missile is not guaranteed to provide the data requested, so the upstream device should check
  /// the [Status](#IUX.Status) message for which values were provided.  
  /// Generally sent BSC -> Missile.
  /// </summary>
  public sealed partial class RequestStatus : pb::IMessage<RequestStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RequestStatus> _parser = new pb::MessageParser<RequestStatus>(() => new RequestStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RequestStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestStatus(RequestStatus other) : this() {
      missileId_ = other.missileId_;
      latitude_ = other.latitude_;
      longitude_ = other.longitude_;
      altitude_ = other.altitude_;
      range_ = other.range_;
      timeToIntercept_ = other.timeToIntercept_;
      roll_ = other.roll_;
      pitch_ = other.pitch_;
      yaw_ = other.yaw_;
      signal_ = other.signal_;
      sensors_ = other.sensors_;
      batteryLevel_ = other.batteryLevel_;
      gpsTime_ = other.gpsTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestStatus Clone() {
      return new RequestStatus(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "latitude" field.</summary>
    public const int LatitudeFieldNumber = 2;
    private bool latitude_;
    /// <summary>
    /// Request the Missile's latitude
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Latitude {
      get { return latitude_; }
      set {
        latitude_ = value;
      }
    }

    /// <summary>Field number for the "longitude" field.</summary>
    public const int LongitudeFieldNumber = 3;
    private bool longitude_;
    /// <summary>
    /// Request the Missile's longitude
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Longitude {
      get { return longitude_; }
      set {
        longitude_ = value;
      }
    }

    /// <summary>Field number for the "altitude" field.</summary>
    public const int AltitudeFieldNumber = 4;
    private bool altitude_;
    /// <summary>
    /// Request the Missile's altitude
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Altitude {
      get { return altitude_; }
      set {
        altitude_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 5;
    private bool range_;
    /// <summary>
    /// Request the Missile's distance from launch
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    /// <summary>Field number for the "time_to_intercept" field.</summary>
    public const int TimeToInterceptFieldNumber = 6;
    private bool timeToIntercept_;
    /// <summary>
    /// Request the Missile's time left until expected intercept (Seconds)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TimeToIntercept {
      get { return timeToIntercept_; }
      set {
        timeToIntercept_ = value;
      }
    }

    /// <summary>Field number for the "roll" field.</summary>
    public const int RollFieldNumber = 7;
    private bool roll_;
    /// <summary>
    /// Request the Missile's Roll orientation (Rotation about the long axis)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Roll {
      get { return roll_; }
      set {
        roll_ = value;
      }
    }

    /// <summary>Field number for the "pitch" field.</summary>
    public const int PitchFieldNumber = 8;
    private bool pitch_;
    /// <summary>
    /// Request the Missile's Pitch orientation (Rotation about the pitch canard axis)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Pitch {
      get { return pitch_; }
      set {
        pitch_ = value;
      }
    }

    /// <summary>Field number for the "yaw" field.</summary>
    public const int YawFieldNumber = 9;
    private bool yaw_;
    /// <summary>
    /// Request the Missile's Yaw orientation (The current heading of the missile)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Yaw {
      get { return yaw_; }
      set {
        yaw_ = value;
      }
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 10;
    private bool signal_;
    /// <summary>
    /// Request the Missile's signal strength (Cellular, RF, etc.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Signal {
      get { return signal_; }
      set {
        signal_ = value;
      }
    }

    /// <summary>Field number for the "sensors" field.</summary>
    public const int SensorsFieldNumber = 11;
    private bool sensors_;
    /// <summary>
    /// Request the Missile's sensor status
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Sensors {
      get { return sensors_; }
      set {
        sensors_ = value;
      }
    }

    /// <summary>Field number for the "battery_level" field.</summary>
    public const int BatteryLevelFieldNumber = 12;
    private bool batteryLevel_;
    /// <summary>
    /// Request the Missile's Battery level (Often, Missile will return this anyway, but should request explicitly if needed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BatteryLevel {
      get { return batteryLevel_; }
      set {
        batteryLevel_ = value;
      }
    }

    /// <summary>Field number for the "gps_time" field.</summary>
    public const int GpsTimeFieldNumber = 13;
    private ulong gpsTime_;
    /// <summary>
    /// The GPS time of the request message (Currently unused, Carryover from IUX v4.0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong GpsTime {
      get { return gpsTime_; }
      set {
        gpsTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RequestStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RequestStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (Latitude != other.Latitude) return false;
      if (Longitude != other.Longitude) return false;
      if (Altitude != other.Altitude) return false;
      if (Range != other.Range) return false;
      if (TimeToIntercept != other.TimeToIntercept) return false;
      if (Roll != other.Roll) return false;
      if (Pitch != other.Pitch) return false;
      if (Yaw != other.Yaw) return false;
      if (Signal != other.Signal) return false;
      if (Sensors != other.Sensors) return false;
      if (BatteryLevel != other.BatteryLevel) return false;
      if (GpsTime != other.GpsTime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (Latitude != false) hash ^= Latitude.GetHashCode();
      if (Longitude != false) hash ^= Longitude.GetHashCode();
      if (Altitude != false) hash ^= Altitude.GetHashCode();
      if (Range != false) hash ^= Range.GetHashCode();
      if (TimeToIntercept != false) hash ^= TimeToIntercept.GetHashCode();
      if (Roll != false) hash ^= Roll.GetHashCode();
      if (Pitch != false) hash ^= Pitch.GetHashCode();
      if (Yaw != false) hash ^= Yaw.GetHashCode();
      if (Signal != false) hash ^= Signal.GetHashCode();
      if (Sensors != false) hash ^= Sensors.GetHashCode();
      if (BatteryLevel != false) hash ^= BatteryLevel.GetHashCode();
      if (GpsTime != 0UL) hash ^= GpsTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Latitude != false) {
        output.WriteRawTag(16);
        output.WriteBool(Latitude);
      }
      if (Longitude != false) {
        output.WriteRawTag(24);
        output.WriteBool(Longitude);
      }
      if (Altitude != false) {
        output.WriteRawTag(32);
        output.WriteBool(Altitude);
      }
      if (Range != false) {
        output.WriteRawTag(40);
        output.WriteBool(Range);
      }
      if (TimeToIntercept != false) {
        output.WriteRawTag(48);
        output.WriteBool(TimeToIntercept);
      }
      if (Roll != false) {
        output.WriteRawTag(56);
        output.WriteBool(Roll);
      }
      if (Pitch != false) {
        output.WriteRawTag(64);
        output.WriteBool(Pitch);
      }
      if (Yaw != false) {
        output.WriteRawTag(72);
        output.WriteBool(Yaw);
      }
      if (Signal != false) {
        output.WriteRawTag(80);
        output.WriteBool(Signal);
      }
      if (Sensors != false) {
        output.WriteRawTag(88);
        output.WriteBool(Sensors);
      }
      if (BatteryLevel != false) {
        output.WriteRawTag(96);
        output.WriteBool(BatteryLevel);
      }
      if (GpsTime != 0UL) {
        output.WriteRawTag(104);
        output.WriteUInt64(GpsTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (Latitude != false) {
        output.WriteRawTag(16);
        output.WriteBool(Latitude);
      }
      if (Longitude != false) {
        output.WriteRawTag(24);
        output.WriteBool(Longitude);
      }
      if (Altitude != false) {
        output.WriteRawTag(32);
        output.WriteBool(Altitude);
      }
      if (Range != false) {
        output.WriteRawTag(40);
        output.WriteBool(Range);
      }
      if (TimeToIntercept != false) {
        output.WriteRawTag(48);
        output.WriteBool(TimeToIntercept);
      }
      if (Roll != false) {
        output.WriteRawTag(56);
        output.WriteBool(Roll);
      }
      if (Pitch != false) {
        output.WriteRawTag(64);
        output.WriteBool(Pitch);
      }
      if (Yaw != false) {
        output.WriteRawTag(72);
        output.WriteBool(Yaw);
      }
      if (Signal != false) {
        output.WriteRawTag(80);
        output.WriteBool(Signal);
      }
      if (Sensors != false) {
        output.WriteRawTag(88);
        output.WriteBool(Sensors);
      }
      if (BatteryLevel != false) {
        output.WriteRawTag(96);
        output.WriteBool(BatteryLevel);
      }
      if (GpsTime != 0UL) {
        output.WriteRawTag(104);
        output.WriteUInt64(GpsTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (Latitude != false) {
        size += 1 + 1;
      }
      if (Longitude != false) {
        size += 1 + 1;
      }
      if (Altitude != false) {
        size += 1 + 1;
      }
      if (Range != false) {
        size += 1 + 1;
      }
      if (TimeToIntercept != false) {
        size += 1 + 1;
      }
      if (Roll != false) {
        size += 1 + 1;
      }
      if (Pitch != false) {
        size += 1 + 1;
      }
      if (Yaw != false) {
        size += 1 + 1;
      }
      if (Signal != false) {
        size += 1 + 1;
      }
      if (Sensors != false) {
        size += 1 + 1;
      }
      if (BatteryLevel != false) {
        size += 1 + 1;
      }
      if (GpsTime != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GpsTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RequestStatus other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.Latitude != false) {
        Latitude = other.Latitude;
      }
      if (other.Longitude != false) {
        Longitude = other.Longitude;
      }
      if (other.Altitude != false) {
        Altitude = other.Altitude;
      }
      if (other.Range != false) {
        Range = other.Range;
      }
      if (other.TimeToIntercept != false) {
        TimeToIntercept = other.TimeToIntercept;
      }
      if (other.Roll != false) {
        Roll = other.Roll;
      }
      if (other.Pitch != false) {
        Pitch = other.Pitch;
      }
      if (other.Yaw != false) {
        Yaw = other.Yaw;
      }
      if (other.Signal != false) {
        Signal = other.Signal;
      }
      if (other.Sensors != false) {
        Sensors = other.Sensors;
      }
      if (other.BatteryLevel != false) {
        BatteryLevel = other.BatteryLevel;
      }
      if (other.GpsTime != 0UL) {
        GpsTime = other.GpsTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            Latitude = input.ReadBool();
            break;
          }
          case 24: {
            Longitude = input.ReadBool();
            break;
          }
          case 32: {
            Altitude = input.ReadBool();
            break;
          }
          case 40: {
            Range = input.ReadBool();
            break;
          }
          case 48: {
            TimeToIntercept = input.ReadBool();
            break;
          }
          case 56: {
            Roll = input.ReadBool();
            break;
          }
          case 64: {
            Pitch = input.ReadBool();
            break;
          }
          case 72: {
            Yaw = input.ReadBool();
            break;
          }
          case 80: {
            Signal = input.ReadBool();
            break;
          }
          case 88: {
            Sensors = input.ReadBool();
            break;
          }
          case 96: {
            BatteryLevel = input.ReadBool();
            break;
          }
          case 104: {
            GpsTime = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            Latitude = input.ReadBool();
            break;
          }
          case 24: {
            Longitude = input.ReadBool();
            break;
          }
          case 32: {
            Altitude = input.ReadBool();
            break;
          }
          case 40: {
            Range = input.ReadBool();
            break;
          }
          case 48: {
            TimeToIntercept = input.ReadBool();
            break;
          }
          case 56: {
            Roll = input.ReadBool();
            break;
          }
          case 64: {
            Pitch = input.ReadBool();
            break;
          }
          case 72: {
            Yaw = input.ReadBool();
            break;
          }
          case 80: {
            Signal = input.ReadBool();
            break;
          }
          case 88: {
            Sensors = input.ReadBool();
            break;
          }
          case 96: {
            BatteryLevel = input.ReadBool();
            break;
          }
          case 104: {
            GpsTime = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Sent upstream of the Missile, Generally Missile -> BSC.  
  /// Message can be sent on an interval or as a reply to a [RequestStatus](#IUX.RequestStatus) message.  
  /// This message contain a bunch of optional data. Some is always included, but that comes down to 
  /// the specific missile's flight firmware configuration.
  /// </summary>
  public sealed partial class Status : pb::IMessage<Status>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Status> _parser = new pb::MessageParser<Status>(() => new Status());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Status> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status(Status other) : this() {
      _hasBits0 = other._hasBits0;
      missileId_ = other.missileId_;
      statusCode_ = other.statusCode_;
      errorCode_ = other.errorCode_;
      position_ = other.position_ != null ? other.position_.Clone() : null;
      range_ = other.range_;
      timeToIntercept_ = other.timeToIntercept_;
      roll_ = other.roll_;
      pitch_ = other.pitch_;
      yaw_ = other.yaw_;
      signal_ = other.signal_;
      imuState_ = other.imuState_;
      gpsState_ = other.gpsState_;
      pressureState_ = other.pressureState_;
      magState_ = other.magState_;
      batteryLevel_ = other.batteryLevel_;
      blockConfig_ = other.blockConfig_;
      gpstime_ = other.gpstime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status Clone() {
      return new Status(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile (sender).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private global::IUX.StatusCode statusCode_ = global::IUX.StatusCode.Nostatus;
    /// <summary>
    /// The status of the missile
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.StatusCode StatusCode {
      get { return statusCode_; }
      set {
        statusCode_ = value;
      }
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 17;
    private uint errorCode_;
    /// <summary>
    /// If there is one, the Error code the missile is reporting
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ErrorCode {
      get { if ((_hasBits0 & 2048) != 0) { return errorCode_; } else { return 0; } }
      set {
        _hasBits0 |= 2048;
        errorCode_ = value;
      }
    }
    /// <summary>Gets whether the "error_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasErrorCode {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "error_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearErrorCode() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 3;
    private global::IUX.Location position_;
    /// <summary>
    /// The position of the missile (Generally [Point3](#IUX.Point3) ECEF or [LatLonAlt](#IUX.LatLonAlt))
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 4;
    private float range_;
    /// <summary>
    /// The missile's distance from the launch location
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Range {
      get { if ((_hasBits0 & 1) != 0) { return range_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        range_ = value;
      }
    }
    /// <summary>Gets whether the "range" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRange {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "range" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRange() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "time_to_intercept" field.</summary>
    public const int TimeToInterceptFieldNumber = 5;
    private float timeToIntercept_;
    /// <summary>
    /// The missile's expected time until intercept (seconds)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TimeToIntercept {
      get { if ((_hasBits0 & 2) != 0) { return timeToIntercept_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        timeToIntercept_ = value;
      }
    }
    /// <summary>Gets whether the "time_to_intercept" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTimeToIntercept {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "time_to_intercept" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTimeToIntercept() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "roll" field.</summary>
    public const int RollFieldNumber = 6;
    private float roll_;
    /// <summary>
    /// The missile's Roll orientation (Rotation about the long axis)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Roll {
      get { if ((_hasBits0 & 4) != 0) { return roll_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        roll_ = value;
      }
    }
    /// <summary>Gets whether the "roll" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRoll {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "roll" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRoll() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "pitch" field.</summary>
    public const int PitchFieldNumber = 7;
    private float pitch_;
    /// <summary>
    /// The missile's Pitch orientation (Rotation about the pitch canard ax
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Pitch {
      get { if ((_hasBits0 & 8) != 0) { return pitch_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        pitch_ = value;
      }
    }
    /// <summary>Gets whether the "pitch" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPitch {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "pitch" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPitch() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "yaw" field.</summary>
    public const int YawFieldNumber = 8;
    private float yaw_;
    /// <summary>
    /// The missile's Yaw orientation (The current heading of the missile)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Yaw {
      get { if ((_hasBits0 & 16) != 0) { return yaw_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        yaw_ = value;
      }
    }
    /// <summary>Gets whether the "yaw" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYaw {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "yaw" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYaw() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 9;
    private float signal_;
    /// <summary>
    /// The missile's signal strength (value and range depends on the missile type and present hardware)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Signal {
      get { if ((_hasBits0 & 32) != 0) { return signal_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        signal_ = value;
      }
    }
    /// <summary>Gets whether the "signal" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSignal {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "signal" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSignal() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "imu_state" field.</summary>
    public const int ImuStateFieldNumber = 10;
    private bool imuState_;
    /// <summary>
    /// The state of the IMU
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ImuState {
      get { if ((_hasBits0 & 64) != 0) { return imuState_; } else { return false; } }
      set {
        _hasBits0 |= 64;
        imuState_ = value;
      }
    }
    /// <summary>Gets whether the "imu_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasImuState {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "imu_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearImuState() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "gps_state" field.</summary>
    public const int GpsStateFieldNumber = 11;
    private bool gpsState_;
    /// <summary>
    /// The state of the GPS
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GpsState {
      get { if ((_hasBits0 & 128) != 0) { return gpsState_; } else { return false; } }
      set {
        _hasBits0 |= 128;
        gpsState_ = value;
      }
    }
    /// <summary>Gets whether the "gps_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGpsState {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "gps_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGpsState() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "pressure_state" field.</summary>
    public const int PressureStateFieldNumber = 12;
    private bool pressureState_;
    /// <summary>
    /// The state of the pressure sensor
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PressureState {
      get { if ((_hasBits0 & 256) != 0) { return pressureState_; } else { return false; } }
      set {
        _hasBits0 |= 256;
        pressureState_ = value;
      }
    }
    /// <summary>Gets whether the "pressure_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPressureState {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "pressure_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPressureState() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "mag_state" field.</summary>
    public const int MagStateFieldNumber = 13;
    private bool magState_;
    /// <summary>
    /// The state of the magnetometer
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MagState {
      get { if ((_hasBits0 & 512) != 0) { return magState_; } else { return false; } }
      set {
        _hasBits0 |= 512;
        magState_ = value;
      }
    }
    /// <summary>Gets whether the "mag_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMagState {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "mag_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMagState() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "battery_level" field.</summary>
    public const int BatteryLevelFieldNumber = 14;
    private float batteryLevel_;
    /// <summary>
    /// The battery level (Missiles update this value very rarely, to conserve battery life, But state is reported)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float BatteryLevel {
      get { if ((_hasBits0 & 1024) != 0) { return batteryLevel_; } else { return 0F; } }
      set {
        _hasBits0 |= 1024;
        batteryLevel_ = value;
      }
    }
    /// <summary>Gets whether the "battery_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBatteryLevel {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "battery_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBatteryLevel() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "block_config" field.</summary>
    public const int BlockConfigFieldNumber = 15;
    private global::IUX.BlockConfig blockConfig_ = global::IUX.BlockConfig.Noblock;
    /// <summary>
    /// The block version of the missile, Signifies version/type of the missile hardware
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.BlockConfig BlockConfig {
      get { return blockConfig_; }
      set {
        blockConfig_ = value;
      }
    }

    /// <summary>Field number for the "gpstime" field.</summary>
    public const int GpstimeFieldNumber = 16;
    private ulong gpstime_;
    /// <summary>
    /// The GPS timestamp of the message (Unclear meanign currently, Unused, carryover from IUX v4.0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Gpstime {
      get { return gpstime_; }
      set {
        gpstime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Status);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Status other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (StatusCode != other.StatusCode) return false;
      if (ErrorCode != other.ErrorCode) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Range, other.Range)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TimeToIntercept, other.TimeToIntercept)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Roll, other.Roll)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Pitch, other.Pitch)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Yaw, other.Yaw)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Signal, other.Signal)) return false;
      if (ImuState != other.ImuState) return false;
      if (GpsState != other.GpsState) return false;
      if (PressureState != other.PressureState) return false;
      if (MagState != other.MagState) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BatteryLevel, other.BatteryLevel)) return false;
      if (BlockConfig != other.BlockConfig) return false;
      if (Gpstime != other.Gpstime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (StatusCode != global::IUX.StatusCode.Nostatus) hash ^= StatusCode.GetHashCode();
      if (HasErrorCode) hash ^= ErrorCode.GetHashCode();
      if (position_ != null) hash ^= Position.GetHashCode();
      if (HasRange) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Range);
      if (HasTimeToIntercept) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TimeToIntercept);
      if (HasRoll) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Roll);
      if (HasPitch) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Pitch);
      if (HasYaw) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Yaw);
      if (HasSignal) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Signal);
      if (HasImuState) hash ^= ImuState.GetHashCode();
      if (HasGpsState) hash ^= GpsState.GetHashCode();
      if (HasPressureState) hash ^= PressureState.GetHashCode();
      if (HasMagState) hash ^= MagState.GetHashCode();
      if (HasBatteryLevel) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BatteryLevel);
      if (BlockConfig != global::IUX.BlockConfig.Noblock) hash ^= BlockConfig.GetHashCode();
      if (Gpstime != 0UL) hash ^= Gpstime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (StatusCode != global::IUX.StatusCode.Nostatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) StatusCode);
      }
      if (position_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Position);
      }
      if (HasRange) {
        output.WriteRawTag(37);
        output.WriteFloat(Range);
      }
      if (HasTimeToIntercept) {
        output.WriteRawTag(45);
        output.WriteFloat(TimeToIntercept);
      }
      if (HasRoll) {
        output.WriteRawTag(53);
        output.WriteFloat(Roll);
      }
      if (HasPitch) {
        output.WriteRawTag(61);
        output.WriteFloat(Pitch);
      }
      if (HasYaw) {
        output.WriteRawTag(69);
        output.WriteFloat(Yaw);
      }
      if (HasSignal) {
        output.WriteRawTag(77);
        output.WriteFloat(Signal);
      }
      if (HasImuState) {
        output.WriteRawTag(80);
        output.WriteBool(ImuState);
      }
      if (HasGpsState) {
        output.WriteRawTag(88);
        output.WriteBool(GpsState);
      }
      if (HasPressureState) {
        output.WriteRawTag(96);
        output.WriteBool(PressureState);
      }
      if (HasMagState) {
        output.WriteRawTag(104);
        output.WriteBool(MagState);
      }
      if (HasBatteryLevel) {
        output.WriteRawTag(117);
        output.WriteFloat(BatteryLevel);
      }
      if (BlockConfig != global::IUX.BlockConfig.Noblock) {
        output.WriteRawTag(120);
        output.WriteEnum((int) BlockConfig);
      }
      if (Gpstime != 0UL) {
        output.WriteRawTag(128, 1);
        output.WriteUInt64(Gpstime);
      }
      if (HasErrorCode) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (StatusCode != global::IUX.StatusCode.Nostatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) StatusCode);
      }
      if (position_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Position);
      }
      if (HasRange) {
        output.WriteRawTag(37);
        output.WriteFloat(Range);
      }
      if (HasTimeToIntercept) {
        output.WriteRawTag(45);
        output.WriteFloat(TimeToIntercept);
      }
      if (HasRoll) {
        output.WriteRawTag(53);
        output.WriteFloat(Roll);
      }
      if (HasPitch) {
        output.WriteRawTag(61);
        output.WriteFloat(Pitch);
      }
      if (HasYaw) {
        output.WriteRawTag(69);
        output.WriteFloat(Yaw);
      }
      if (HasSignal) {
        output.WriteRawTag(77);
        output.WriteFloat(Signal);
      }
      if (HasImuState) {
        output.WriteRawTag(80);
        output.WriteBool(ImuState);
      }
      if (HasGpsState) {
        output.WriteRawTag(88);
        output.WriteBool(GpsState);
      }
      if (HasPressureState) {
        output.WriteRawTag(96);
        output.WriteBool(PressureState);
      }
      if (HasMagState) {
        output.WriteRawTag(104);
        output.WriteBool(MagState);
      }
      if (HasBatteryLevel) {
        output.WriteRawTag(117);
        output.WriteFloat(BatteryLevel);
      }
      if (BlockConfig != global::IUX.BlockConfig.Noblock) {
        output.WriteRawTag(120);
        output.WriteEnum((int) BlockConfig);
      }
      if (Gpstime != 0UL) {
        output.WriteRawTag(128, 1);
        output.WriteUInt64(Gpstime);
      }
      if (HasErrorCode) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (StatusCode != global::IUX.StatusCode.Nostatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) StatusCode);
      }
      if (HasErrorCode) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(ErrorCode);
      }
      if (position_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (HasRange) {
        size += 1 + 4;
      }
      if (HasTimeToIntercept) {
        size += 1 + 4;
      }
      if (HasRoll) {
        size += 1 + 4;
      }
      if (HasPitch) {
        size += 1 + 4;
      }
      if (HasYaw) {
        size += 1 + 4;
      }
      if (HasSignal) {
        size += 1 + 4;
      }
      if (HasImuState) {
        size += 1 + 1;
      }
      if (HasGpsState) {
        size += 1 + 1;
      }
      if (HasPressureState) {
        size += 1 + 1;
      }
      if (HasMagState) {
        size += 1 + 1;
      }
      if (HasBatteryLevel) {
        size += 1 + 4;
      }
      if (BlockConfig != global::IUX.BlockConfig.Noblock) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BlockConfig);
      }
      if (Gpstime != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(Gpstime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Status other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.StatusCode != global::IUX.StatusCode.Nostatus) {
        StatusCode = other.StatusCode;
      }
      if (other.HasErrorCode) {
        ErrorCode = other.ErrorCode;
      }
      if (other.position_ != null) {
        if (position_ == null) {
          Position = new global::IUX.Location();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.HasRange) {
        Range = other.Range;
      }
      if (other.HasTimeToIntercept) {
        TimeToIntercept = other.TimeToIntercept;
      }
      if (other.HasRoll) {
        Roll = other.Roll;
      }
      if (other.HasPitch) {
        Pitch = other.Pitch;
      }
      if (other.HasYaw) {
        Yaw = other.Yaw;
      }
      if (other.HasSignal) {
        Signal = other.Signal;
      }
      if (other.HasImuState) {
        ImuState = other.ImuState;
      }
      if (other.HasGpsState) {
        GpsState = other.GpsState;
      }
      if (other.HasPressureState) {
        PressureState = other.PressureState;
      }
      if (other.HasMagState) {
        MagState = other.MagState;
      }
      if (other.HasBatteryLevel) {
        BatteryLevel = other.BatteryLevel;
      }
      if (other.BlockConfig != global::IUX.BlockConfig.Noblock) {
        BlockConfig = other.BlockConfig;
      }
      if (other.Gpstime != 0UL) {
        Gpstime = other.Gpstime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            StatusCode = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 26: {
            if (position_ == null) {
              Position = new global::IUX.Location();
            }
            input.ReadMessage(Position);
            break;
          }
          case 37: {
            Range = input.ReadFloat();
            break;
          }
          case 45: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 53: {
            Roll = input.ReadFloat();
            break;
          }
          case 61: {
            Pitch = input.ReadFloat();
            break;
          }
          case 69: {
            Yaw = input.ReadFloat();
            break;
          }
          case 77: {
            Signal = input.ReadFloat();
            break;
          }
          case 80: {
            ImuState = input.ReadBool();
            break;
          }
          case 88: {
            GpsState = input.ReadBool();
            break;
          }
          case 96: {
            PressureState = input.ReadBool();
            break;
          }
          case 104: {
            MagState = input.ReadBool();
            break;
          }
          case 117: {
            BatteryLevel = input.ReadFloat();
            break;
          }
          case 120: {
            BlockConfig = (global::IUX.BlockConfig) input.ReadEnum();
            break;
          }
          case 128: {
            Gpstime = input.ReadUInt64();
            break;
          }
          case 136: {
            ErrorCode = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 16: {
            StatusCode = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 26: {
            if (position_ == null) {
              Position = new global::IUX.Location();
            }
            input.ReadMessage(Position);
            break;
          }
          case 37: {
            Range = input.ReadFloat();
            break;
          }
          case 45: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 53: {
            Roll = input.ReadFloat();
            break;
          }
          case 61: {
            Pitch = input.ReadFloat();
            break;
          }
          case 69: {
            Yaw = input.ReadFloat();
            break;
          }
          case 77: {
            Signal = input.ReadFloat();
            break;
          }
          case 80: {
            ImuState = input.ReadBool();
            break;
          }
          case 88: {
            GpsState = input.ReadBool();
            break;
          }
          case 96: {
            PressureState = input.ReadBool();
            break;
          }
          case 104: {
            MagState = input.ReadBool();
            break;
          }
          case 117: {
            BatteryLevel = input.ReadFloat();
            break;
          }
          case 120: {
            BlockConfig = (global::IUX.BlockConfig) input.ReadEnum();
            break;
          }
          case 128: {
            Gpstime = input.ReadUInt64();
            break;
          }
          case 136: {
            ErrorCode = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Unused message, Carryover from IUX v4.0  
  /// May be used/redefined when seeking missiles switch to IUX Protobuf
  /// </summary>
  public sealed partial class Tracking : pb::IMessage<Tracking>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Tracking> _parser = new pb::MessageParser<Tracking>(() => new Tracking());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Tracking> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracking() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracking(Tracking other) : this() {
      missileId_ = other.missileId_;
      bearingToTarget_ = other.bearingToTarget_;
      distanceToIntercept_ = other.distanceToIntercept_;
      timeToIntercept_ = other.timeToIntercept_;
      velocity_ = other.velocity_;
      targetClass_ = other.targetClass_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracking Clone() {
      return new Tracking(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "bearing_to_target" field.</summary>
    public const int BearingToTargetFieldNumber = 2;
    private float bearingToTarget_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float BearingToTarget {
      get { return bearingToTarget_; }
      set {
        bearingToTarget_ = value;
      }
    }

    /// <summary>Field number for the "distance_to_intercept" field.</summary>
    public const int DistanceToInterceptFieldNumber = 3;
    private float distanceToIntercept_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DistanceToIntercept {
      get { return distanceToIntercept_; }
      set {
        distanceToIntercept_ = value;
      }
    }

    /// <summary>Field number for the "time_to_intercept" field.</summary>
    public const int TimeToInterceptFieldNumber = 4;
    private float timeToIntercept_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TimeToIntercept {
      get { return timeToIntercept_; }
      set {
        timeToIntercept_ = value;
      }
    }

    /// <summary>Field number for the "velocity" field.</summary>
    public const int VelocityFieldNumber = 5;
    private float velocity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Velocity {
      get { return velocity_; }
      set {
        velocity_ = value;
      }
    }

    /// <summary>Field number for the "target_class" field.</summary>
    public const int TargetClassFieldNumber = 6;
    private global::IUX.TargetClass targetClass_ = global::IUX.TargetClass.NoTargetClass;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.TargetClass TargetClass {
      get { return targetClass_; }
      set {
        targetClass_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Tracking);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Tracking other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BearingToTarget, other.BearingToTarget)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DistanceToIntercept, other.DistanceToIntercept)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TimeToIntercept, other.TimeToIntercept)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Velocity, other.Velocity)) return false;
      if (TargetClass != other.TargetClass) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (BearingToTarget != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BearingToTarget);
      if (DistanceToIntercept != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DistanceToIntercept);
      if (TimeToIntercept != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TimeToIntercept);
      if (Velocity != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Velocity);
      if (TargetClass != global::IUX.TargetClass.NoTargetClass) hash ^= TargetClass.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (BearingToTarget != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(BearingToTarget);
      }
      if (DistanceToIntercept != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(DistanceToIntercept);
      }
      if (TimeToIntercept != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(TimeToIntercept);
      }
      if (Velocity != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Velocity);
      }
      if (TargetClass != global::IUX.TargetClass.NoTargetClass) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TargetClass);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (BearingToTarget != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(BearingToTarget);
      }
      if (DistanceToIntercept != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(DistanceToIntercept);
      }
      if (TimeToIntercept != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(TimeToIntercept);
      }
      if (Velocity != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Velocity);
      }
      if (TargetClass != global::IUX.TargetClass.NoTargetClass) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TargetClass);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (BearingToTarget != 0F) {
        size += 1 + 4;
      }
      if (DistanceToIntercept != 0F) {
        size += 1 + 4;
      }
      if (TimeToIntercept != 0F) {
        size += 1 + 4;
      }
      if (Velocity != 0F) {
        size += 1 + 4;
      }
      if (TargetClass != global::IUX.TargetClass.NoTargetClass) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TargetClass);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Tracking other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.BearingToTarget != 0F) {
        BearingToTarget = other.BearingToTarget;
      }
      if (other.DistanceToIntercept != 0F) {
        DistanceToIntercept = other.DistanceToIntercept;
      }
      if (other.TimeToIntercept != 0F) {
        TimeToIntercept = other.TimeToIntercept;
      }
      if (other.Velocity != 0F) {
        Velocity = other.Velocity;
      }
      if (other.TargetClass != global::IUX.TargetClass.NoTargetClass) {
        TargetClass = other.TargetClass;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            BearingToTarget = input.ReadFloat();
            break;
          }
          case 29: {
            DistanceToIntercept = input.ReadFloat();
            break;
          }
          case 37: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 45: {
            Velocity = input.ReadFloat();
            break;
          }
          case 48: {
            TargetClass = (global::IUX.TargetClass) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            BearingToTarget = input.ReadFloat();
            break;
          }
          case 29: {
            DistanceToIntercept = input.ReadFloat();
            break;
          }
          case 37: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 45: {
            Velocity = input.ReadFloat();
            break;
          }
          case 48: {
            TargetClass = (global::IUX.TargetClass) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for Disarming a missile  
  /// This message is most applicable while the missile is on the BSC rail.  
  /// The missile should disarm when this missile is received any time it is unlaunched (armed or not).
  /// </summary>
  public sealed partial class Disarm : pb::IMessage<Disarm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Disarm> _parser = new pb::MessageParser<Disarm>(() => new Disarm());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Disarm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disarm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disarm(Disarm other) : this() {
      missileId_ = other.missileId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disarm Clone() {
      return new Disarm(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Disarm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Disarm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Disarm other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile control message for resetting a missile.  
  /// Generally used to reset the missile to default state and often to reboot the flight controller and general flight systems.  
  /// Can clear error codes and cause a full diconnected/reconnect.
  /// </summary>
  public sealed partial class Reset : pb::IMessage<Reset>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Reset> _parser = new pb::MessageParser<Reset>(() => new Reset());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Reset> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Reset() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Reset(Reset other) : this() {
      missileId_ = other.missileId_;
      baseStationId_ = other.baseStationId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Reset Clone() {
      return new Reset(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    /// <summary>
    /// The ID of the missile. This is chcecked on the missile to make sure the message was meant for that missile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 2;
    private uint baseStationId_;
    /// <summary>
    /// The upstream BSC sending the reset message (Not needed, defaults to 0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Reset);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Reset other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (BaseStationId != other.BaseStationId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (BaseStationId != 0) {
        output.WriteRawTag(21);
        output.WriteFixed32(BaseStationId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (BaseStationId != 0) {
        output.WriteRawTag(21);
        output.WriteFixed32(BaseStationId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Reset other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            BaseStationId = input.ReadFixed32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 21: {
            BaseStationId = input.ReadFixed32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret Control message for requesting the status of all the missile rails.  
  /// Returns the status information of teh missiles on the rails.  
  /// Functionally, the Turret equivalent of the [RequestStatus](#IUX.RequestStatus) message.  
  /// Contains a list of booleans for which data to request.  
  /// Expects a [RailStatus](#IUX.RailStatus) reply message
  ///
  /// Generally sent:  
  /// BSS -> BSC  
  /// ASSURE -> BSC
  /// </summary>
  public sealed partial class RailStatusRequest : pb::IMessage<RailStatusRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RailStatusRequest> _parser = new pb::MessageParser<RailStatusRequest>(() => new RailStatusRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RailStatusRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatusRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatusRequest(RailStatusRequest other) : this() {
      baseStationId_ = other.baseStationId_;
      position_ = other.position_;
      attitude_ = other.attitude_;
      signal_ = other.signal_;
      missileStates_ = other.missileStates_;
      railStates_ = other.railStates_;
      blockConfig_ = other.blockConfig_;
      batteryLevels_ = other.batteryLevels_;
      gpsTime_ = other.gpsTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatusRequest Clone() {
      return new RailStatusRequest(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the BSC 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    private bool position_;
    /// <summary>
    /// Request the Positions of the missiles (mainly useful of radio contact is maintained after launch)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "attitude" field.</summary>
    public const int AttitudeFieldNumber = 3;
    private bool attitude_;
    /// <summary>
    /// Request the attitude of the missiles
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Attitude {
      get { return attitude_; }
      set {
        attitude_ = value;
      }
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 4;
    private bool signal_;
    /// <summary>
    /// Request the Signal strength of the missiles (For Cellular or RF)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Signal {
      get { return signal_; }
      set {
        signal_ = value;
      }
    }

    /// <summary>Field number for the "missile_states" field.</summary>
    public const int MissileStatesFieldNumber = 5;
    private bool missileStates_;
    /// <summary>
    /// Request the missile states (Generally always returned anyway, but should be specified if needed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MissileStates {
      get { return missileStates_; }
      set {
        missileStates_ = value;
      }
    }

    /// <summary>Field number for the "rail_states" field.</summary>
    public const int RailStatesFieldNumber = 6;
    private bool railStates_;
    /// <summary>
    /// Request the rail states. Rail states are what the Turret/BSC is trying to configure the missile to (Generally, missile_state and rail_state match. But not always)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RailStates {
      get { return railStates_; }
      set {
        railStates_ = value;
      }
    }

    /// <summary>Field number for the "block_config" field.</summary>
    public const int BlockConfigFieldNumber = 7;
    private bool blockConfig_;
    /// <summary>
    /// Request the Block config data of the missiles (Generally always returned anyway, but should be specified if needed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BlockConfig {
      get { return blockConfig_; }
      set {
        blockConfig_ = value;
      }
    }

    /// <summary>Field number for the "battery_levels" field.</summary>
    public const int BatteryLevelsFieldNumber = 8;
    private bool batteryLevels_;
    /// <summary>
    /// Request the Battery level of the missiles (Generally always returned anyway, but should be specified if needed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BatteryLevels {
      get { return batteryLevels_; }
      set {
        batteryLevels_ = value;
      }
    }

    /// <summary>Field number for the "gps_time" field.</summary>
    public const int GpsTimeFieldNumber = 9;
    private ulong gpsTime_;
    /// <summary>
    /// The GPS timestamp of the request message (Currentl unused, carryover from IUX v4.0)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong GpsTime {
      get { return gpsTime_; }
      set {
        gpsTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RailStatusRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RailStatusRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Position != other.Position) return false;
      if (Attitude != other.Attitude) return false;
      if (Signal != other.Signal) return false;
      if (MissileStates != other.MissileStates) return false;
      if (RailStates != other.RailStates) return false;
      if (BlockConfig != other.BlockConfig) return false;
      if (BatteryLevels != other.BatteryLevels) return false;
      if (GpsTime != other.GpsTime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Position != false) hash ^= Position.GetHashCode();
      if (Attitude != false) hash ^= Attitude.GetHashCode();
      if (Signal != false) hash ^= Signal.GetHashCode();
      if (MissileStates != false) hash ^= MissileStates.GetHashCode();
      if (RailStates != false) hash ^= RailStates.GetHashCode();
      if (BlockConfig != false) hash ^= BlockConfig.GetHashCode();
      if (BatteryLevels != false) hash ^= BatteryLevels.GetHashCode();
      if (GpsTime != 0UL) hash ^= GpsTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Position != false) {
        output.WriteRawTag(16);
        output.WriteBool(Position);
      }
      if (Attitude != false) {
        output.WriteRawTag(24);
        output.WriteBool(Attitude);
      }
      if (Signal != false) {
        output.WriteRawTag(32);
        output.WriteBool(Signal);
      }
      if (MissileStates != false) {
        output.WriteRawTag(40);
        output.WriteBool(MissileStates);
      }
      if (RailStates != false) {
        output.WriteRawTag(48);
        output.WriteBool(RailStates);
      }
      if (BlockConfig != false) {
        output.WriteRawTag(56);
        output.WriteBool(BlockConfig);
      }
      if (BatteryLevels != false) {
        output.WriteRawTag(64);
        output.WriteBool(BatteryLevels);
      }
      if (GpsTime != 0UL) {
        output.WriteRawTag(72);
        output.WriteUInt64(GpsTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Position != false) {
        output.WriteRawTag(16);
        output.WriteBool(Position);
      }
      if (Attitude != false) {
        output.WriteRawTag(24);
        output.WriteBool(Attitude);
      }
      if (Signal != false) {
        output.WriteRawTag(32);
        output.WriteBool(Signal);
      }
      if (MissileStates != false) {
        output.WriteRawTag(40);
        output.WriteBool(MissileStates);
      }
      if (RailStates != false) {
        output.WriteRawTag(48);
        output.WriteBool(RailStates);
      }
      if (BlockConfig != false) {
        output.WriteRawTag(56);
        output.WriteBool(BlockConfig);
      }
      if (BatteryLevels != false) {
        output.WriteRawTag(64);
        output.WriteBool(BatteryLevels);
      }
      if (GpsTime != 0UL) {
        output.WriteRawTag(72);
        output.WriteUInt64(GpsTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Position != false) {
        size += 1 + 1;
      }
      if (Attitude != false) {
        size += 1 + 1;
      }
      if (Signal != false) {
        size += 1 + 1;
      }
      if (MissileStates != false) {
        size += 1 + 1;
      }
      if (RailStates != false) {
        size += 1 + 1;
      }
      if (BlockConfig != false) {
        size += 1 + 1;
      }
      if (BatteryLevels != false) {
        size += 1 + 1;
      }
      if (GpsTime != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GpsTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RailStatusRequest other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Position != false) {
        Position = other.Position;
      }
      if (other.Attitude != false) {
        Attitude = other.Attitude;
      }
      if (other.Signal != false) {
        Signal = other.Signal;
      }
      if (other.MissileStates != false) {
        MissileStates = other.MissileStates;
      }
      if (other.RailStates != false) {
        RailStates = other.RailStates;
      }
      if (other.BlockConfig != false) {
        BlockConfig = other.BlockConfig;
      }
      if (other.BatteryLevels != false) {
        BatteryLevels = other.BatteryLevels;
      }
      if (other.GpsTime != 0UL) {
        GpsTime = other.GpsTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Position = input.ReadBool();
            break;
          }
          case 24: {
            Attitude = input.ReadBool();
            break;
          }
          case 32: {
            Signal = input.ReadBool();
            break;
          }
          case 40: {
            MissileStates = input.ReadBool();
            break;
          }
          case 48: {
            RailStates = input.ReadBool();
            break;
          }
          case 56: {
            BlockConfig = input.ReadBool();
            break;
          }
          case 64: {
            BatteryLevels = input.ReadBool();
            break;
          }
          case 72: {
            GpsTime = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Position = input.ReadBool();
            break;
          }
          case 24: {
            Attitude = input.ReadBool();
            break;
          }
          case 32: {
            Signal = input.ReadBool();
            break;
          }
          case 40: {
            MissileStates = input.ReadBool();
            break;
          }
          case 48: {
            RailStates = input.ReadBool();
            break;
          }
          case 56: {
            BlockConfig = input.ReadBool();
            break;
          }
          case 64: {
            BatteryLevels = input.ReadBool();
            break;
          }
          case 72: {
            GpsTime = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret output message for reporting the state of the missiles.  
  /// Sent either on a regular interval or as a reply to a [TurretStatusRequest](#IUX.TurretStatusRequest) message.  
  /// Contains optional test data. Each repeated field contains the data for all the missiles.
  /// The repeated fields may not all have the same length due to Missile Banks.  
  /// Missile Banks dont report all the same data and may not have data to add for certain fields.  
  /// The indexs for the missiles all line up:  
  /// 
  /// Eg. `position[0]` contains the 1st missile's position, and `attitude[1]` contains the 2nd missile's attitude
  /// </summary>
  public sealed partial class RailStatus : pb::IMessage<RailStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RailStatus> _parser = new pb::MessageParser<RailStatus>(() => new RailStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RailStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatus(RailStatus other) : this() {
      baseStationId_ = other.baseStationId_;
      missileId_ = other.missileId_.Clone();
      position_ = other.position_.Clone();
      attitude_ = other.attitude_.Clone();
      signal_ = other.signal_.Clone();
      missileStates_ = other.missileStates_.Clone();
      railStates_ = other.railStates_.Clone();
      blockConfig_ = other.blockConfig_.Clone();
      batteryLevels_ = other.batteryLevels_.Clone();
      errorCode_ = other.errorCode_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RailStatus Clone() {
      return new RailStatus(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the BSC (sender)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_missileId_codec
        = pb::FieldCodec.ForFixed32(18);
    private readonly pbc::RepeatedField<uint> missileId_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// The IDs of the missiles
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> MissileId {
      get { return missileId_; }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 3;
    private static readonly pb::FieldCodec<global::IUX.Location> _repeated_position_codec
        = pb::FieldCodec.ForMessage(26, global::IUX.Location.Parser);
    private readonly pbc::RepeatedField<global::IUX.Location> position_ = new pbc::RepeatedField<global::IUX.Location>();
    /// <summary>
    /// The Positions of the missiles (mainly useful of radio contact is maintained after launch)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::IUX.Location> Position {
      get { return position_; }
    }

    /// <summary>Field number for the "attitude" field.</summary>
    public const int AttitudeFieldNumber = 4;
    private static readonly pb::FieldCodec<global::IUX.Attitude> _repeated_attitude_codec
        = pb::FieldCodec.ForMessage(34, global::IUX.Attitude.Parser);
    private readonly pbc::RepeatedField<global::IUX.Attitude> attitude_ = new pbc::RepeatedField<global::IUX.Attitude>();
    /// <summary>
    /// The attitude of the missiles
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::IUX.Attitude> Attitude {
      get { return attitude_; }
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 5;
    private static readonly pb::FieldCodec<float> _repeated_signal_codec
        = pb::FieldCodec.ForFloat(42);
    private readonly pbc::RepeatedField<float> signal_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// The Signal strength of the missiles (For Cellular or RF)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Signal {
      get { return signal_; }
    }

    /// <summary>Field number for the "missile_states" field.</summary>
    public const int MissileStatesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::IUX.StatusCode> _repeated_missileStates_codec
        = pb::FieldCodec.ForEnum(50, x => (int) x, x => (global::IUX.StatusCode) x);
    private readonly pbc::RepeatedField<global::IUX.StatusCode> missileStates_ = new pbc::RepeatedField<global::IUX.StatusCode>();
    /// <summary>
    /// The missile states (Generally always returned)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::IUX.StatusCode> MissileStates {
      get { return missileStates_; }
    }

    /// <summary>Field number for the "rail_states" field.</summary>
    public const int RailStatesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::IUX.StatusCode> _repeated_railStates_codec
        = pb::FieldCodec.ForEnum(58, x => (int) x, x => (global::IUX.StatusCode) x);
    private readonly pbc::RepeatedField<global::IUX.StatusCode> railStates_ = new pbc::RepeatedField<global::IUX.StatusCode>();
    /// <summary>
    /// The rail states. Rail states are what the Turret/BSC is trying to configure the missile to (Generally, missile_state and rail_state match. But not always)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::IUX.StatusCode> RailStates {
      get { return railStates_; }
    }

    /// <summary>Field number for the "block_config" field.</summary>
    public const int BlockConfigFieldNumber = 8;
    private static readonly pb::FieldCodec<global::IUX.BlockConfig> _repeated_blockConfig_codec
        = pb::FieldCodec.ForEnum(66, x => (int) x, x => (global::IUX.BlockConfig) x);
    private readonly pbc::RepeatedField<global::IUX.BlockConfig> blockConfig_ = new pbc::RepeatedField<global::IUX.BlockConfig>();
    /// <summary>
    /// The Block config data of the missiles (Generally always returned)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::IUX.BlockConfig> BlockConfig {
      get { return blockConfig_; }
    }

    /// <summary>Field number for the "battery_levels" field.</summary>
    public const int BatteryLevelsFieldNumber = 9;
    private static readonly pb::FieldCodec<float> _repeated_batteryLevels_codec
        = pb::FieldCodec.ForFloat(74);
    private readonly pbc::RepeatedField<float> batteryLevels_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// The Battery level of the missiles (Generally always returned)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> BatteryLevels {
      get { return batteryLevels_; }
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 10;
    private static readonly pb::FieldCodec<uint> _repeated_errorCode_codec
        = pb::FieldCodec.ForUInt32(82);
    private readonly pbc::RepeatedField<uint> errorCode_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// The error code of the missiles, if there is one (0 is no-error)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> ErrorCode {
      get { return errorCode_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RailStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RailStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if(!missileId_.Equals(other.missileId_)) return false;
      if(!position_.Equals(other.position_)) return false;
      if(!attitude_.Equals(other.attitude_)) return false;
      if(!signal_.Equals(other.signal_)) return false;
      if(!missileStates_.Equals(other.missileStates_)) return false;
      if(!railStates_.Equals(other.railStates_)) return false;
      if(!blockConfig_.Equals(other.blockConfig_)) return false;
      if(!batteryLevels_.Equals(other.batteryLevels_)) return false;
      if(!errorCode_.Equals(other.errorCode_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      hash ^= missileId_.GetHashCode();
      hash ^= position_.GetHashCode();
      hash ^= attitude_.GetHashCode();
      hash ^= signal_.GetHashCode();
      hash ^= missileStates_.GetHashCode();
      hash ^= railStates_.GetHashCode();
      hash ^= blockConfig_.GetHashCode();
      hash ^= batteryLevels_.GetHashCode();
      hash ^= errorCode_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      missileId_.WriteTo(output, _repeated_missileId_codec);
      position_.WriteTo(output, _repeated_position_codec);
      attitude_.WriteTo(output, _repeated_attitude_codec);
      signal_.WriteTo(output, _repeated_signal_codec);
      missileStates_.WriteTo(output, _repeated_missileStates_codec);
      railStates_.WriteTo(output, _repeated_railStates_codec);
      blockConfig_.WriteTo(output, _repeated_blockConfig_codec);
      batteryLevels_.WriteTo(output, _repeated_batteryLevels_codec);
      errorCode_.WriteTo(output, _repeated_errorCode_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      missileId_.WriteTo(ref output, _repeated_missileId_codec);
      position_.WriteTo(ref output, _repeated_position_codec);
      attitude_.WriteTo(ref output, _repeated_attitude_codec);
      signal_.WriteTo(ref output, _repeated_signal_codec);
      missileStates_.WriteTo(ref output, _repeated_missileStates_codec);
      railStates_.WriteTo(ref output, _repeated_railStates_codec);
      blockConfig_.WriteTo(ref output, _repeated_blockConfig_codec);
      batteryLevels_.WriteTo(ref output, _repeated_batteryLevels_codec);
      errorCode_.WriteTo(ref output, _repeated_errorCode_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      size += missileId_.CalculateSize(_repeated_missileId_codec);
      size += position_.CalculateSize(_repeated_position_codec);
      size += attitude_.CalculateSize(_repeated_attitude_codec);
      size += signal_.CalculateSize(_repeated_signal_codec);
      size += missileStates_.CalculateSize(_repeated_missileStates_codec);
      size += railStates_.CalculateSize(_repeated_railStates_codec);
      size += blockConfig_.CalculateSize(_repeated_blockConfig_codec);
      size += batteryLevels_.CalculateSize(_repeated_batteryLevels_codec);
      size += errorCode_.CalculateSize(_repeated_errorCode_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RailStatus other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      missileId_.Add(other.missileId_);
      position_.Add(other.position_);
      attitude_.Add(other.attitude_);
      signal_.Add(other.signal_);
      missileStates_.Add(other.missileStates_);
      railStates_.Add(other.railStates_);
      blockConfig_.Add(other.blockConfig_);
      batteryLevels_.Add(other.batteryLevels_);
      errorCode_.Add(other.errorCode_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18:
          case 21: {
            missileId_.AddEntriesFrom(input, _repeated_missileId_codec);
            break;
          }
          case 26: {
            position_.AddEntriesFrom(input, _repeated_position_codec);
            break;
          }
          case 34: {
            attitude_.AddEntriesFrom(input, _repeated_attitude_codec);
            break;
          }
          case 42:
          case 45: {
            signal_.AddEntriesFrom(input, _repeated_signal_codec);
            break;
          }
          case 50:
          case 48: {
            missileStates_.AddEntriesFrom(input, _repeated_missileStates_codec);
            break;
          }
          case 58:
          case 56: {
            railStates_.AddEntriesFrom(input, _repeated_railStates_codec);
            break;
          }
          case 66:
          case 64: {
            blockConfig_.AddEntriesFrom(input, _repeated_blockConfig_codec);
            break;
          }
          case 74:
          case 77: {
            batteryLevels_.AddEntriesFrom(input, _repeated_batteryLevels_codec);
            break;
          }
          case 82:
          case 80: {
            errorCode_.AddEntriesFrom(input, _repeated_errorCode_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18:
          case 21: {
            missileId_.AddEntriesFrom(ref input, _repeated_missileId_codec);
            break;
          }
          case 26: {
            position_.AddEntriesFrom(ref input, _repeated_position_codec);
            break;
          }
          case 34: {
            attitude_.AddEntriesFrom(ref input, _repeated_attitude_codec);
            break;
          }
          case 42:
          case 45: {
            signal_.AddEntriesFrom(ref input, _repeated_signal_codec);
            break;
          }
          case 50:
          case 48: {
            missileStates_.AddEntriesFrom(ref input, _repeated_missileStates_codec);
            break;
          }
          case 58:
          case 56: {
            railStates_.AddEntriesFrom(ref input, _repeated_railStates_codec);
            break;
          }
          case 66:
          case 64: {
            blockConfig_.AddEntriesFrom(ref input, _repeated_blockConfig_codec);
            break;
          }
          case 74:
          case 77: {
            batteryLevels_.AddEntriesFrom(ref input, _repeated_batteryLevels_codec);
            break;
          }
          case 82:
          case 80: {
            errorCode_.AddEntriesFrom(ref input, _repeated_errorCode_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret Control message for manually setting the Azimuth Elevation of the launch rails.  
  /// This message is intended to serve as a manual control message for the ASSURE terminal.  
  /// These should be used as one-off messages. For constant target tracking, use the [TurretTrack](#IUX.TurretTrack) message.
  /// </summary>
  public sealed partial class TurretCueToTarget : pb::IMessage<TurretCueToTarget>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretCueToTarget> _parser = new pb::MessageParser<TurretCueToTarget>(() => new TurretCueToTarget());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretCueToTarget> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCueToTarget() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCueToTarget(TurretCueToTarget other) : this() {
      baseStationId_ = other.baseStationId_;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCueToTarget Clone() {
      return new TurretCueToTarget(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 2;
    private global::IUX.Location target_;
    /// <summary>
    /// The Location of the target. This can only be an [AzElT2](#IUX.AzElT2) style location, since the BSC is not intended to handle BSS request for these messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretCueToTarget);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretCueToTarget other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretCueToTarget other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret Control message for manual movement and calibration.  
  /// This message is intended to be used for manually controlling the movement of the BSC turret.  
  /// The message is intended to contain 1 type of control.  
  ///
  /// - Auto Calibrate  
  /// - Manual Calibrate  
  /// - Movement Command
  ///
  /// _(If multiple are specified, only the first is honoured, checked in the above order of precedence)_
  /// </summary>
  public sealed partial class TurretCalibrate : pb::IMessage<TurretCalibrate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretCalibrate> _parser = new pb::MessageParser<TurretCalibrate>(() => new TurretCalibrate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretCalibrate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCalibrate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCalibrate(TurretCalibrate other) : this() {
      _hasBits0 = other._hasBits0;
      baseStationId_ = other.baseStationId_;
      movement_ = other.movement_;
      movementDirection_ = other.movementDirection_;
      stepSize_ = other.stepSize_;
      elevation_ = other.elevation_;
      azimuth_ = other.azimuth_;
      autoCalibrate_ = other.autoCalibrate_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretCalibrate Clone() {
      return new TurretCalibrate(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "movement" field.</summary>
    public const int MovementFieldNumber = 2;
    private global::IUX.TurretCalibrate.Types.Movement movement_;
    /// <summary>
    /// Dictate the type of movement to employ
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.TurretCalibrate.Types.Movement Movement {
      get { if ((_hasBits0 & 1) != 0) { return movement_; } else { return global::IUX.TurretCalibrate.Types.Movement.Stepped; } }
      set {
        _hasBits0 |= 1;
        movement_ = value;
      }
    }
    /// <summary>Gets whether the "movement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMovement {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "movement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMovement() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "movement_direction" field.</summary>
    public const int MovementDirectionFieldNumber = 3;
    private global::IUX.TurretCalibrate.Types.MovementDirection movementDirection_;
    /// <summary>
    /// The axis/direction to control the motors
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.TurretCalibrate.Types.MovementDirection MovementDirection {
      get { if ((_hasBits0 & 2) != 0) { return movementDirection_; } else { return global::IUX.TurretCalibrate.Types.MovementDirection.Cancel; } }
      set {
        _hasBits0 |= 2;
        movementDirection_ = value;
      }
    }
    /// <summary>Gets whether the "movement_direction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMovementDirection {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "movement_direction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMovementDirection() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "step_size" field.</summary>
    public const int StepSizeFieldNumber = 4;
    private float stepSize_;
    /// <summary>
    /// Optionally, the size of the stepwise movement. Unless specified, and stepsize of 1 degree is used. (Value in degrees, fractional allowed)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StepSize {
      get { if ((_hasBits0 & 4) != 0) { return stepSize_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        stepSize_ = value;
      }
    }
    /// <summary>Gets whether the "step_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStepSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "step_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStepSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "elevation" field.</summary>
    public const int ElevationFieldNumber = 5;
    private float elevation_;
    /// <summary>
    /// The manual calibration Elevation (Both Elevation and Azimuth must be specified to manually calibrate)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Elevation {
      get { if ((_hasBits0 & 8) != 0) { return elevation_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        elevation_ = value;
      }
    }
    /// <summary>Gets whether the "elevation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasElevation {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "elevation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearElevation() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "azimuth" field.</summary>
    public const int AzimuthFieldNumber = 6;
    private float azimuth_;
    /// <summary>
    /// The manual calibration Azimuth (Both Elevation and Azimuth must be specified to manually calibrate)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Azimuth {
      get { if ((_hasBits0 & 16) != 0) { return azimuth_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        azimuth_ = value;
      }
    }
    /// <summary>Gets whether the "azimuth" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAzimuth {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "azimuth" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAzimuth() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "auto_calibrate" field.</summary>
    public const int AutoCalibrateFieldNumber = 7;
    private bool autoCalibrate_;
    /// <summary>
    /// Whether to start the auto-calibrate sequence or not (Defaults to false)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AutoCalibrate {
      get { return autoCalibrate_; }
      set {
        autoCalibrate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretCalibrate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretCalibrate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Movement != other.Movement) return false;
      if (MovementDirection != other.MovementDirection) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StepSize, other.StepSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Elevation, other.Elevation)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Azimuth, other.Azimuth)) return false;
      if (AutoCalibrate != other.AutoCalibrate) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (HasMovement) hash ^= Movement.GetHashCode();
      if (HasMovementDirection) hash ^= MovementDirection.GetHashCode();
      if (HasStepSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StepSize);
      if (HasElevation) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Elevation);
      if (HasAzimuth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Azimuth);
      if (AutoCalibrate != false) hash ^= AutoCalibrate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (HasMovement) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Movement);
      }
      if (HasMovementDirection) {
        output.WriteRawTag(24);
        output.WriteEnum((int) MovementDirection);
      }
      if (HasStepSize) {
        output.WriteRawTag(37);
        output.WriteFloat(StepSize);
      }
      if (HasElevation) {
        output.WriteRawTag(45);
        output.WriteFloat(Elevation);
      }
      if (HasAzimuth) {
        output.WriteRawTag(53);
        output.WriteFloat(Azimuth);
      }
      if (AutoCalibrate != false) {
        output.WriteRawTag(56);
        output.WriteBool(AutoCalibrate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (HasMovement) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Movement);
      }
      if (HasMovementDirection) {
        output.WriteRawTag(24);
        output.WriteEnum((int) MovementDirection);
      }
      if (HasStepSize) {
        output.WriteRawTag(37);
        output.WriteFloat(StepSize);
      }
      if (HasElevation) {
        output.WriteRawTag(45);
        output.WriteFloat(Elevation);
      }
      if (HasAzimuth) {
        output.WriteRawTag(53);
        output.WriteFloat(Azimuth);
      }
      if (AutoCalibrate != false) {
        output.WriteRawTag(56);
        output.WriteBool(AutoCalibrate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (HasMovement) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Movement);
      }
      if (HasMovementDirection) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MovementDirection);
      }
      if (HasStepSize) {
        size += 1 + 4;
      }
      if (HasElevation) {
        size += 1 + 4;
      }
      if (HasAzimuth) {
        size += 1 + 4;
      }
      if (AutoCalibrate != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretCalibrate other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.HasMovement) {
        Movement = other.Movement;
      }
      if (other.HasMovementDirection) {
        MovementDirection = other.MovementDirection;
      }
      if (other.HasStepSize) {
        StepSize = other.StepSize;
      }
      if (other.HasElevation) {
        Elevation = other.Elevation;
      }
      if (other.HasAzimuth) {
        Azimuth = other.Azimuth;
      }
      if (other.AutoCalibrate != false) {
        AutoCalibrate = other.AutoCalibrate;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Movement = (global::IUX.TurretCalibrate.Types.Movement) input.ReadEnum();
            break;
          }
          case 24: {
            MovementDirection = (global::IUX.TurretCalibrate.Types.MovementDirection) input.ReadEnum();
            break;
          }
          case 37: {
            StepSize = input.ReadFloat();
            break;
          }
          case 45: {
            Elevation = input.ReadFloat();
            break;
          }
          case 53: {
            Azimuth = input.ReadFloat();
            break;
          }
          case 56: {
            AutoCalibrate = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Movement = (global::IUX.TurretCalibrate.Types.Movement) input.ReadEnum();
            break;
          }
          case 24: {
            MovementDirection = (global::IUX.TurretCalibrate.Types.MovementDirection) input.ReadEnum();
            break;
          }
          case 37: {
            StepSize = input.ReadFloat();
            break;
          }
          case 45: {
            Elevation = input.ReadFloat();
            break;
          }
          case 53: {
            Azimuth = input.ReadFloat();
            break;
          }
          case 56: {
            AutoCalibrate = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TurretCalibrate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///*
      /// Movement type enumerator  
      /// To dictate which type of movement should be used for the [TurretCalibrate](#IUX.TurretCalibrate) command
      /// </summary>
      public enum Movement {
        /// <summary>
        /// Stepwise movement, Allows movement at a specified step width
        /// </summary>
        [pbr::OriginalName("STEPPED")] Stepped = 0,
        /// <summary>
        /// Continuous movement, starts the motors moving and doesnt stop until told to.
        /// </summary>
        [pbr::OriginalName("CONTINUOUS")] Continuous = 1,
      }

      /// <summary>
      ///*
      /// The direction of movement to use for a [TurretCalibrate](#IUX.TurretCalibrate) command
      /// </summary>
      public enum MovementDirection {
        /// <summary>
        /// Stop the movement (in all axis). Used to stop continous movement, but can also smoothly stop stepwise movement or general turret movement.
        /// </summary>
        [pbr::OriginalName("CANCEL")] Cancel = 0,
        /// <summary>
        /// Move the Azimuth Counter-Clockwise (from the top view). Decreasing degrees of Azimuth
        /// </summary>
        [pbr::OriginalName("LEFT")] Left = 1,
        /// <summary>
        /// Move the Elevation upward (From the side view). Increasing degrees of Angle of Elevation
        /// </summary>
        [pbr::OriginalName("UP")] Up = 2,
        /// <summary>
        /// Move the Azimuth Clockwise (from the top view). Increasing degrees of Azimuth
        /// </summary>
        [pbr::OriginalName("RIGHT")] Right = 3,
        /// <summary>
        /// Move the Elevation downward (From the side view). Decreasing degrees of Angle of Elevation
        /// </summary>
        [pbr::OriginalName("DOWN")] Down = 4,
      }

    }
    #endregion

  }

  /// <summary>
  ///*
  /// Turret control message for ___Immediately___ stopping the motors.  
  /// This is intended as a digital E-stop, and should force the motors to stop without
  /// deceleration (Stop as soon as possible, even if that means losing steps or calibration)  
  ///
  /// The BSC will become uncalibrated, as the stop may have caused loss of precision.
  /// The BSC must recalibrated before accepting normal movement commands (use 
  /// [TurretCalibrate](#IUX.TurretCalibrate) to control calibration).
  /// </summary>
  public sealed partial class TurretEmergencyStop : pb::IMessage<TurretEmergencyStop>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretEmergencyStop> _parser = new pb::MessageParser<TurretEmergencyStop>(() => new TurretEmergencyStop());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretEmergencyStop> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretEmergencyStop() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretEmergencyStop(TurretEmergencyStop other) : this() {
      baseStationId_ = other.baseStationId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretEmergencyStop Clone() {
      return new TurretEmergencyStop(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretEmergencyStop);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretEmergencyStop other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretEmergencyStop other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for continuous targeting information.  
  /// This message is intended to be used to have the turret track a target. That means this
  /// message is intended to be sent repeatedly to update the targets location.
  /// The targets location can be provided using any [Location](#IUX.Location) format, as
  /// long as the BSC has a connected to the BSS for it to acquire ballistic solutions.
  /// 
  /// This message can be sent as a one-off message or as a constant stream of messages.
  /// The BSC should be able to handle a constant flow and continuously update the Turrets movements.
  /// </summary>
  public sealed partial class TurretTrack : pb::IMessage<TurretTrack>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretTrack> _parser = new pb::MessageParser<TurretTrack>(() => new TurretTrack());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretTrack> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretTrack() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretTrack(TurretTrack other) : this() {
      baseStationId_ = other.baseStationId_;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretTrack Clone() {
      return new TurretTrack(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 2;
    private global::IUX.Location target_;
    /// <summary>
    /// The targets location. If [AzElT2](#IUX.AzElT2), The turret goes to those absolute angles (or local angles if no correction 
    /// available from sensors). For other [Location](#IUX.Location) formats, the BSC sends a [BSSRequest](#IUX.BSSRequest) with the 
    /// bool `reply_with_turret_track` value set. This tells the BSS to send back a [TurretTrack](#IUX.TurretTrack) message with the 
    /// [AzElT2](#IUX.AzElT2) target data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretTrack);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretTrack other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretTrack other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for requesting a [TurretStatus](#IUX.TurretStatus) message.  
  /// This message is similair to the [StatusRequest](#IUX.StatusRequest) message, but is
  /// intended for Turret status, not missile status. This does not request a 
  /// [RailStatus](#IUX.RailStatus) message, that needs to be done seperately through
  /// the [RequestRailStatus](#IUX.RequestRailStatus) message.
  ///
  /// This message contains a list of booleans for which data to request from the BSC.
  /// </summary>
  public sealed partial class TurretStatusRequest : pb::IMessage<TurretStatusRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretStatusRequest> _parser = new pb::MessageParser<TurretStatusRequest>(() => new TurretStatusRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretStatusRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatusRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatusRequest(TurretStatusRequest other) : this() {
      baseStationId_ = other.baseStationId_;
      position_ = other.position_;
      dynamics_ = other.dynamics_;
      attitude_ = other.attitude_;
      bssConnection_ = other.bssConnection_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatusRequest Clone() {
      return new TurretStatusRequest(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    private bool position_;
    /// <summary>
    /// The Position of the BSC, generally provided as [LatLonAlt](#IUX.LatLonAlt) or [Point3](#IUX.Point3) ECEF
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "dynamics" field.</summary>
    public const int DynamicsFieldNumber = 3;
    private bool dynamics_;
    /// <summary>
    /// The Velocity and Acceleration of the BSC/Turret. Used in cases of mobile mounted Turret systems
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Dynamics {
      get { return dynamics_; }
      set {
        dynamics_ = value;
      }
    }

    /// <summary>Field number for the "attitude" field.</summary>
    public const int AttitudeFieldNumber = 4;
    private bool attitude_;
    /// <summary>
    /// The Attitude of the Turret base (The current Azimuth/Elevation)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Attitude {
      get { return attitude_; }
      set {
        attitude_ = value;
      }
    }

    /// <summary>Field number for the "bss_connection" field.</summary>
    public const int BssConnectionFieldNumber = 5;
    private bool bssConnection_;
    /// <summary>
    /// Request the status of the BSC's BSS Connection connection status
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BssConnection {
      get { return bssConnection_; }
      set {
        bssConnection_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretStatusRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretStatusRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Position != other.Position) return false;
      if (Dynamics != other.Dynamics) return false;
      if (Attitude != other.Attitude) return false;
      if (BssConnection != other.BssConnection) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Position != false) hash ^= Position.GetHashCode();
      if (Dynamics != false) hash ^= Dynamics.GetHashCode();
      if (Attitude != false) hash ^= Attitude.GetHashCode();
      if (BssConnection != false) hash ^= BssConnection.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Position != false) {
        output.WriteRawTag(16);
        output.WriteBool(Position);
      }
      if (Dynamics != false) {
        output.WriteRawTag(24);
        output.WriteBool(Dynamics);
      }
      if (Attitude != false) {
        output.WriteRawTag(32);
        output.WriteBool(Attitude);
      }
      if (BssConnection != false) {
        output.WriteRawTag(40);
        output.WriteBool(BssConnection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Position != false) {
        output.WriteRawTag(16);
        output.WriteBool(Position);
      }
      if (Dynamics != false) {
        output.WriteRawTag(24);
        output.WriteBool(Dynamics);
      }
      if (Attitude != false) {
        output.WriteRawTag(32);
        output.WriteBool(Attitude);
      }
      if (BssConnection != false) {
        output.WriteRawTag(40);
        output.WriteBool(BssConnection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Position != false) {
        size += 1 + 1;
      }
      if (Dynamics != false) {
        size += 1 + 1;
      }
      if (Attitude != false) {
        size += 1 + 1;
      }
      if (BssConnection != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretStatusRequest other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Position != false) {
        Position = other.Position;
      }
      if (other.Dynamics != false) {
        Dynamics = other.Dynamics;
      }
      if (other.Attitude != false) {
        Attitude = other.Attitude;
      }
      if (other.BssConnection != false) {
        BssConnection = other.BssConnection;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Position = input.ReadBool();
            break;
          }
          case 24: {
            Dynamics = input.ReadBool();
            break;
          }
          case 32: {
            Attitude = input.ReadBool();
            break;
          }
          case 40: {
            BssConnection = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Position = input.ReadBool();
            break;
          }
          case 24: {
            Dynamics = input.ReadBool();
            break;
          }
          case 32: {
            Attitude = input.ReadBool();
            break;
          }
          case 40: {
            BssConnection = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret reply message to send status information to an upstream device.  
  /// This message is either sent at a regular interval or as a reply to a [TurretStatusRequest](#IUX.TurretStatusRequest).
  /// All status values are optional, but some may be included by default. It a value is needed, it should be explicitly
  /// requested to ensure it is sent. Some request may not be able to be sent, so the Upstream device (ASSURE, BSS) should
  /// Check for the values presence before reading it, otherwise a default value may be accidentally read.
  /// </summary>
  public sealed partial class TurretStatus : pb::IMessage<TurretStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretStatus> _parser = new pb::MessageParser<TurretStatus>(() => new TurretStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatus(TurretStatus other) : this() {
      _hasBits0 = other._hasBits0;
      baseStationId_ = other.baseStationId_;
      position_ = other.position_ != null ? other.position_.Clone() : null;
      velocity_ = other.velocity_ != null ? other.velocity_.Clone() : null;
      acceleration_ = other.acceleration_ != null ? other.acceleration_.Clone() : null;
      attitudeValid_ = other.attitudeValid_;
      current_ = other.current_ != null ? other.current_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      moving_ = other.moving_;
      bssConnection_ = other.bssConnection_;
      errorCode_ = other.errorCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretStatus Clone() {
      return new TurretStatus(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the BSC sending the message
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    private global::IUX.Location position_;
    /// <summary>
    /// The Turret/BSC's position, generally provided as [LatLonAlt](#IUX.LatLonAlt) or [Point3](#IUX.Point3). Aligns with `bool position` in [TurretStatusRequest](#IUX.TurretStatusRequest).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "velocity" field.</summary>
    public const int VelocityFieldNumber = 3;
    private global::IUX.Point3 velocity_;
    /// <summary>
    /// The Turret/BSC/s Velocity in X, Y, and Z. Requested with `bool dynamics` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 Velocity {
      get { return velocity_; }
      set {
        velocity_ = value;
      }
    }

    /// <summary>Field number for the "acceleration" field.</summary>
    public const int AccelerationFieldNumber = 4;
    private global::IUX.Point3 acceleration_;
    /// <summary>
    /// The Turret/BSC/s Velocity in X, Y, and Z. Requested with `bool dynamics` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 Acceleration {
      get { return acceleration_; }
      set {
        acceleration_ = value;
      }
    }

    /// <summary>Field number for the "attitude_valid" field.</summary>
    public const int AttitudeValidFieldNumber = 5;
    private bool attitudeValid_;
    /// <summary>
    /// Boolean of Whether the BSC knows its attitude. False would represent uncalibrated, True would represent calibrated. Requested with `bool attitude` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AttitudeValid {
      get { if ((_hasBits0 & 1) != 0) { return attitudeValid_; } else { return false; } }
      set {
        _hasBits0 |= 1;
        attitudeValid_ = value;
      }
    }
    /// <summary>Gets whether the "attitude_valid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAttitudeValid {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "attitude_valid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAttitudeValid() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "current" field.</summary>
    public const int CurrentFieldNumber = 6;
    private global::IUX.Attitude current_;
    /// <summary>
    /// The Turret/BSC's current Attitude (Azimuth/Elevation Roll is generally always 0). Requested with `bool attitude` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Attitude Current {
      get { return current_; }
      set {
        current_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 7;
    private global::IUX.Attitude target_;
    /// <summary>
    /// The Turret/BSC's target Attitude (Azimuth/Elevation Roll is generally always 0). The current and target values will likely differ while the Turret is moving. Requested with `bool attitude` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Attitude Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "moving" field.</summary>
    public const int MovingFieldNumber = 8;
    private bool moving_;
    /// <summary>
    /// Boolean of Whether the Turret/BSC is moving. (Azimuth and/or Elevation is changing)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Moving {
      get { if ((_hasBits0 & 2) != 0) { return moving_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        moving_ = value;
      }
    }
    /// <summary>Gets whether the "moving" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMoving {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "moving" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMoving() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "bss_connection" field.</summary>
    public const int BssConnectionFieldNumber = 9;
    private global::IUX.StatusCode bssConnection_;
    /// <summary>
    /// The Status of the BSC &lt;-> BSS Connection (from the BSC side). Requested with `bool bss_connection` in [TurretStatusRequest](#IUX.TurretStatusRequest)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.StatusCode BssConnection {
      get { if ((_hasBits0 & 4) != 0) { return bssConnection_; } else { return global::IUX.StatusCode.Nostatus; } }
      set {
        _hasBits0 |= 4;
        bssConnection_ = value;
      }
    }
    /// <summary>Gets whether the "bss_connection" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBssConnection {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "bss_connection" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBssConnection() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 10;
    private uint errorCode_;
    /// <summary>
    /// If it exists, the error code of the BSC. (Error code 0 is no error, Error codes are device/firmware specific)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ErrorCode {
      get { if ((_hasBits0 & 8) != 0) { return errorCode_; } else { return 0; } }
      set {
        _hasBits0 |= 8;
        errorCode_ = value;
      }
    }
    /// <summary>Gets whether the "error_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasErrorCode {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "error_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearErrorCode() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Velocity, other.Velocity)) return false;
      if (!object.Equals(Acceleration, other.Acceleration)) return false;
      if (AttitudeValid != other.AttitudeValid) return false;
      if (!object.Equals(Current, other.Current)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      if (Moving != other.Moving) return false;
      if (BssConnection != other.BssConnection) return false;
      if (ErrorCode != other.ErrorCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (position_ != null) hash ^= Position.GetHashCode();
      if (velocity_ != null) hash ^= Velocity.GetHashCode();
      if (acceleration_ != null) hash ^= Acceleration.GetHashCode();
      if (HasAttitudeValid) hash ^= AttitudeValid.GetHashCode();
      if (current_ != null) hash ^= Current.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (HasMoving) hash ^= Moving.GetHashCode();
      if (HasBssConnection) hash ^= BssConnection.GetHashCode();
      if (HasErrorCode) hash ^= ErrorCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (velocity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Velocity);
      }
      if (acceleration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Acceleration);
      }
      if (HasAttitudeValid) {
        output.WriteRawTag(40);
        output.WriteBool(AttitudeValid);
      }
      if (current_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Current);
      }
      if (target_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Target);
      }
      if (HasMoving) {
        output.WriteRawTag(64);
        output.WriteBool(Moving);
      }
      if (HasBssConnection) {
        output.WriteRawTag(72);
        output.WriteEnum((int) BssConnection);
      }
      if (HasErrorCode) {
        output.WriteRawTag(80);
        output.WriteUInt32(ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (velocity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Velocity);
      }
      if (acceleration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Acceleration);
      }
      if (HasAttitudeValid) {
        output.WriteRawTag(40);
        output.WriteBool(AttitudeValid);
      }
      if (current_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Current);
      }
      if (target_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Target);
      }
      if (HasMoving) {
        output.WriteRawTag(64);
        output.WriteBool(Moving);
      }
      if (HasBssConnection) {
        output.WriteRawTag(72);
        output.WriteEnum((int) BssConnection);
      }
      if (HasErrorCode) {
        output.WriteRawTag(80);
        output.WriteUInt32(ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (position_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (velocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Velocity);
      }
      if (acceleration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Acceleration);
      }
      if (HasAttitudeValid) {
        size += 1 + 1;
      }
      if (current_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Current);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (HasMoving) {
        size += 1 + 1;
      }
      if (HasBssConnection) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BssConnection);
      }
      if (HasErrorCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ErrorCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretStatus other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.position_ != null) {
        if (position_ == null) {
          Position = new global::IUX.Location();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.velocity_ != null) {
        if (velocity_ == null) {
          Velocity = new global::IUX.Point3();
        }
        Velocity.MergeFrom(other.Velocity);
      }
      if (other.acceleration_ != null) {
        if (acceleration_ == null) {
          Acceleration = new global::IUX.Point3();
        }
        Acceleration.MergeFrom(other.Acceleration);
      }
      if (other.HasAttitudeValid) {
        AttitudeValid = other.AttitudeValid;
      }
      if (other.current_ != null) {
        if (current_ == null) {
          Current = new global::IUX.Attitude();
        }
        Current.MergeFrom(other.Current);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Attitude();
        }
        Target.MergeFrom(other.Target);
      }
      if (other.HasMoving) {
        Moving = other.Moving;
      }
      if (other.HasBssConnection) {
        BssConnection = other.BssConnection;
      }
      if (other.HasErrorCode) {
        ErrorCode = other.ErrorCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (position_ == null) {
              Position = new global::IUX.Location();
            }
            input.ReadMessage(Position);
            break;
          }
          case 26: {
            if (velocity_ == null) {
              Velocity = new global::IUX.Point3();
            }
            input.ReadMessage(Velocity);
            break;
          }
          case 34: {
            if (acceleration_ == null) {
              Acceleration = new global::IUX.Point3();
            }
            input.ReadMessage(Acceleration);
            break;
          }
          case 40: {
            AttitudeValid = input.ReadBool();
            break;
          }
          case 50: {
            if (current_ == null) {
              Current = new global::IUX.Attitude();
            }
            input.ReadMessage(Current);
            break;
          }
          case 58: {
            if (target_ == null) {
              Target = new global::IUX.Attitude();
            }
            input.ReadMessage(Target);
            break;
          }
          case 64: {
            Moving = input.ReadBool();
            break;
          }
          case 72: {
            BssConnection = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 80: {
            ErrorCode = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (position_ == null) {
              Position = new global::IUX.Location();
            }
            input.ReadMessage(Position);
            break;
          }
          case 26: {
            if (velocity_ == null) {
              Velocity = new global::IUX.Point3();
            }
            input.ReadMessage(Velocity);
            break;
          }
          case 34: {
            if (acceleration_ == null) {
              Acceleration = new global::IUX.Point3();
            }
            input.ReadMessage(Acceleration);
            break;
          }
          case 40: {
            AttitudeValid = input.ReadBool();
            break;
          }
          case 50: {
            if (current_ == null) {
              Current = new global::IUX.Attitude();
            }
            input.ReadMessage(Current);
            break;
          }
          case 58: {
            if (target_ == null) {
              Target = new global::IUX.Attitude();
            }
            input.ReadMessage(Target);
            break;
          }
          case 64: {
            Moving = input.ReadBool();
            break;
          }
          case 72: {
            BssConnection = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 80: {
            ErrorCode = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Missile reply message indicating the missile is properly configured and is ready to launch.
  ///
  /// This message is not currently used. (Carryover from IUX v4.0)
  /// </summary>
  public sealed partial class ReadyToLaunch : pb::IMessage<ReadyToLaunch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReadyToLaunch> _parser = new pb::MessageParser<ReadyToLaunch>(() => new ReadyToLaunch());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ReadyToLaunch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadyToLaunch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadyToLaunch(ReadyToLaunch other) : this() {
      _hasBits0 = other._hasBits0;
      missileId_ = other.missileId_;
      flightProfile_ = other.flightProfile_ != null ? other.flightProfile_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      interceptTime_ = other.interceptTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ReadyToLaunch Clone() {
      return new ReadyToLaunch(this);
    }

    /// <summary>Field number for the "missile_id" field.</summary>
    public const int MissileIdFieldNumber = 1;
    private uint missileId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MissileId {
      get { return missileId_; }
      set {
        missileId_ = value;
      }
    }

    /// <summary>Field number for the "flight_profile" field.</summary>
    public const int FlightProfileFieldNumber = 2;
    private global::IUX.FlightProfile flightProfile_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.FlightProfile FlightProfile {
      get { return flightProfile_; }
      set {
        flightProfile_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 3;
    private global::IUX.Location target_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "intercept_time" field.</summary>
    public const int InterceptTimeFieldNumber = 4;
    private uint interceptTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint InterceptTime {
      get { if ((_hasBits0 & 1) != 0) { return interceptTime_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        interceptTime_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "intercept_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptTime() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ReadyToLaunch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ReadyToLaunch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MissileId != other.MissileId) return false;
      if (!object.Equals(FlightProfile, other.FlightProfile)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      if (InterceptTime != other.InterceptTime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MissileId != 0) hash ^= MissileId.GetHashCode();
      if (flightProfile_ != null) hash ^= FlightProfile.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (HasInterceptTime) hash ^= InterceptTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(32);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MissileId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(MissileId);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(32);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MissileId != 0) {
        size += 1 + 4;
      }
      if (flightProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlightProfile);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (HasInterceptTime) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(InterceptTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ReadyToLaunch other) {
      if (other == null) {
        return;
      }
      if (other.MissileId != 0) {
        MissileId = other.MissileId;
      }
      if (other.flightProfile_ != null) {
        if (flightProfile_ == null) {
          FlightProfile = new global::IUX.FlightProfile();
        }
        FlightProfile.MergeFrom(other.FlightProfile);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      if (other.HasInterceptTime) {
        InterceptTime = other.InterceptTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 32: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MissileId = input.ReadFixed32();
            break;
          }
          case 18: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 26: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 32: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for arming a missile rail and the corresponding missile.  
  /// This message is intended to tell the BSC to take the needed steps to Arm a missile and prepare it for launching.
  /// This generally causes an [Arm](#IUX.Arm) message to be sent to the missile, carrying the same data as this message.
  /// </summary>
  public sealed partial class ArmRail : pb::IMessage<ArmRail>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ArmRail> _parser = new pb::MessageParser<ArmRail>(() => new ArmRail());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ArmRail> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmRail() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmRail(ArmRail other) : this() {
      _hasBits0 = other._hasBits0;
      baseStationId_ = other.baseStationId_;
      rail_ = other.rail_;
      turretTrack_ = other.turretTrack_;
      flightProfile_ = other.flightProfile_ != null ? other.flightProfile_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      interceptTime_ = other.interceptTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmRail Clone() {
      return new ArmRail(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 2;
    private uint rail_;
    /// <summary>
    /// The Rail number to arm (and the missile on that rail)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { return rail_; }
      set {
        rail_ = value;
      }
    }

    /// <summary>Field number for the "turret_track" field.</summary>
    public const int TurretTrackFieldNumber = 3;
    private bool turretTrack_;
    /// <summary>
    /// Instruct the BSC to get a BSS Solution and move the Elevation and Azimuth automatically
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TurretTrack {
      get { return turretTrack_; }
      set {
        turretTrack_ = value;
      }
    }

    /// <summary>Field number for the "flight_profile" field.</summary>
    public const int FlightProfileFieldNumber = 4;
    private global::IUX.FlightProfile flightProfile_;
    /// <summary>
    /// The flight profile configuration to pass on to the missile
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.FlightProfile FlightProfile {
      get { return flightProfile_; }
      set {
        flightProfile_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 5;
    private global::IUX.Location target_;
    /// <summary>
    /// The most recent location of the target. Used for BSS solution and passed to missile
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "intercept_time" field.</summary>
    public const int InterceptTimeFieldNumber = 6;
    private uint interceptTime_;
    /// <summary>
    /// The expected intercept time (not currently used)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint InterceptTime {
      get { if ((_hasBits0 & 1) != 0) { return interceptTime_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        interceptTime_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "intercept_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptTime() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ArmRail);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ArmRail other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Rail != other.Rail) return false;
      if (TurretTrack != other.TurretTrack) return false;
      if (!object.Equals(FlightProfile, other.FlightProfile)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      if (InterceptTime != other.InterceptTime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Rail != 0) hash ^= Rail.GetHashCode();
      if (TurretTrack != false) hash ^= TurretTrack.GetHashCode();
      if (flightProfile_ != null) hash ^= FlightProfile.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (HasInterceptTime) hash ^= InterceptTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (TurretTrack != false) {
        output.WriteRawTag(24);
        output.WriteBool(TurretTrack);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(48);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (TurretTrack != false) {
        output.WriteRawTag(24);
        output.WriteBool(TurretTrack);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(48);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Rail != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (TurretTrack != false) {
        size += 1 + 1;
      }
      if (flightProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlightProfile);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (HasInterceptTime) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(InterceptTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ArmRail other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Rail != 0) {
        Rail = other.Rail;
      }
      if (other.TurretTrack != false) {
        TurretTrack = other.TurretTrack;
      }
      if (other.flightProfile_ != null) {
        if (flightProfile_ == null) {
          FlightProfile = new global::IUX.FlightProfile();
        }
        FlightProfile.MergeFrom(other.FlightProfile);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      if (other.HasInterceptTime) {
        InterceptTime = other.InterceptTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
          case 24: {
            TurretTrack = input.ReadBool();
            break;
          }
          case 34: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 42: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 48: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
          case 24: {
            TurretTrack = input.ReadBool();
            break;
          }
          case 34: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 42: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 48: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for Disarming a missile rail.  
  /// This message is intended to tell the BSC to do what is needed to disarm the missile and rail.
  /// This message ___should___ be effective any time the missile is still on the rail. Handling should
  /// be implemented in a robust way.
  /// </summary>
  public sealed partial class DisarmRail : pb::IMessage<DisarmRail>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DisarmRail> _parser = new pb::MessageParser<DisarmRail>(() => new DisarmRail());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DisarmRail> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisarmRail() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisarmRail(DisarmRail other) : this() {
      baseStationId_ = other.baseStationId_;
      rail_ = other.rail_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisarmRail Clone() {
      return new DisarmRail(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 2;
    private uint rail_;
    /// <summary>
    /// The rail number to disarm. Also disarms the missile on the rail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { return rail_; }
      set {
        rail_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DisarmRail);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DisarmRail other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Rail != other.Rail) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Rail != 0) hash ^= Rail.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Rail != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DisarmRail other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Rail != 0) {
        Rail = other.Rail;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for launching a missile on a rail.  
  /// This message is intended to tell the BSC to do what is needed to launch the missile on the specified rail.
  /// The launch sequence may be different for each type of missile, and the BSC is intended to handle that.
  /// This message also includes the option to launch a set of missiles at the same time. This is layed out in
  /// the launch_pattern value.
  /// </summary>
  public sealed partial class LaunchRail : pb::IMessage<LaunchRail>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LaunchRail> _parser = new pb::MessageParser<LaunchRail>(() => new LaunchRail());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaunchRail> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaunchRail() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaunchRail(LaunchRail other) : this() {
      _hasBits0 = other._hasBits0;
      baseStationId_ = other.baseStationId_;
      rail_ = other.rail_;
      launchPattern_ = other.launchPattern_;
      delay_ = other.delay_;
      turretTrack_ = other.turretTrack_;
      flightProfile_ = other.flightProfile_ != null ? other.flightProfile_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      interceptTime_ = other.interceptTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaunchRail Clone() {
      return new LaunchRail(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 2;
    private uint rail_;
    /// <summary>
    /// The rail number to launch (not needed if the launch pattern is not normal)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { if ((_hasBits0 & 1) != 0) { return rail_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        rail_ = value;
      }
    }
    /// <summary>Gets whether the "rail" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRail {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "rail" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRail() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "launch_pattern" field.</summary>
    public const int LaunchPatternFieldNumber = 3;
    private global::IUX.LaunchRail.Types.LaunchPattern launchPattern_ = global::IUX.LaunchRail.Types.LaunchPattern.Normal;
    /// <summary>
    /// The launch pattern to use
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.LaunchRail.Types.LaunchPattern LaunchPattern {
      get { return launchPattern_; }
      set {
        launchPattern_ = value;
      }
    }

    /// <summary>Field number for the "delay" field.</summary>
    public const int DelayFieldNumber = 4;
    private float delay_;
    /// <summary>
    /// If `launch_pattern=NORMAL` this is the delay before launching a single specified missile.  
    /// If `launch_pattern=SEQUENTIAL` this is the delay between launching each armed missile.  
    /// If `launch_pattern=SIMULTANEOUS` this is the delay before launching all armed missiles (Delay __is not__ required for SIMULTANEOUS).  
    /// If `launch_pattern=DELAY` this is the delay before launching all armed missiles (Delay __is__ required for SIMULTANEOUS).   
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Delay {
      get { if ((_hasBits0 & 2) != 0) { return delay_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        delay_ = value;
      }
    }
    /// <summary>Gets whether the "delay" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDelay {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "delay" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDelay() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "turret_track" field.</summary>
    public const int TurretTrackFieldNumber = 5;
    private bool turretTrack_;
    /// <summary>
    /// Instruct the Turret to get a BSS Solution and move the Elevation and Azimuth automatically
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TurretTrack {
      get { return turretTrack_; }
      set {
        turretTrack_ = value;
      }
    }

    /// <summary>Field number for the "flight_profile" field.</summary>
    public const int FlightProfileFieldNumber = 6;
    private global::IUX.FlightProfile flightProfile_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.FlightProfile FlightProfile {
      get { return flightProfile_; }
      set {
        flightProfile_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 7;
    private global::IUX.Location target_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Location Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "intercept_time" field.</summary>
    public const int InterceptTimeFieldNumber = 8;
    private uint interceptTime_;
    /// <summary>
    /// Delay after launch of deployment (Ballistic Control)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint InterceptTime {
      get { if ((_hasBits0 & 4) != 0) { return interceptTime_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        interceptTime_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "intercept_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptTime() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaunchRail);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaunchRail other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Rail != other.Rail) return false;
      if (LaunchPattern != other.LaunchPattern) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Delay, other.Delay)) return false;
      if (TurretTrack != other.TurretTrack) return false;
      if (!object.Equals(FlightProfile, other.FlightProfile)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      if (InterceptTime != other.InterceptTime) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (HasRail) hash ^= Rail.GetHashCode();
      if (LaunchPattern != global::IUX.LaunchRail.Types.LaunchPattern.Normal) hash ^= LaunchPattern.GetHashCode();
      if (HasDelay) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Delay);
      if (TurretTrack != false) hash ^= TurretTrack.GetHashCode();
      if (flightProfile_ != null) hash ^= FlightProfile.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (HasInterceptTime) hash ^= InterceptTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (HasRail) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (LaunchPattern != global::IUX.LaunchRail.Types.LaunchPattern.Normal) {
        output.WriteRawTag(24);
        output.WriteEnum((int) LaunchPattern);
      }
      if (HasDelay) {
        output.WriteRawTag(37);
        output.WriteFloat(Delay);
      }
      if (TurretTrack != false) {
        output.WriteRawTag(40);
        output.WriteBool(TurretTrack);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(64);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (HasRail) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (LaunchPattern != global::IUX.LaunchRail.Types.LaunchPattern.Normal) {
        output.WriteRawTag(24);
        output.WriteEnum((int) LaunchPattern);
      }
      if (HasDelay) {
        output.WriteRawTag(37);
        output.WriteFloat(Delay);
      }
      if (TurretTrack != false) {
        output.WriteRawTag(40);
        output.WriteBool(TurretTrack);
      }
      if (flightProfile_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FlightProfile);
      }
      if (target_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Target);
      }
      if (HasInterceptTime) {
        output.WriteRawTag(64);
        output.WriteUInt32(InterceptTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (HasRail) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (LaunchPattern != global::IUX.LaunchRail.Types.LaunchPattern.Normal) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LaunchPattern);
      }
      if (HasDelay) {
        size += 1 + 4;
      }
      if (TurretTrack != false) {
        size += 1 + 1;
      }
      if (flightProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlightProfile);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (HasInterceptTime) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(InterceptTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaunchRail other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.HasRail) {
        Rail = other.Rail;
      }
      if (other.LaunchPattern != global::IUX.LaunchRail.Types.LaunchPattern.Normal) {
        LaunchPattern = other.LaunchPattern;
      }
      if (other.HasDelay) {
        Delay = other.Delay;
      }
      if (other.TurretTrack != false) {
        TurretTrack = other.TurretTrack;
      }
      if (other.flightProfile_ != null) {
        if (flightProfile_ == null) {
          FlightProfile = new global::IUX.FlightProfile();
        }
        FlightProfile.MergeFrom(other.FlightProfile);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::IUX.Location();
        }
        Target.MergeFrom(other.Target);
      }
      if (other.HasInterceptTime) {
        InterceptTime = other.InterceptTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
          case 24: {
            LaunchPattern = (global::IUX.LaunchRail.Types.LaunchPattern) input.ReadEnum();
            break;
          }
          case 37: {
            Delay = input.ReadFloat();
            break;
          }
          case 40: {
            TurretTrack = input.ReadBool();
            break;
          }
          case 50: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 58: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 64: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
          case 24: {
            LaunchPattern = (global::IUX.LaunchRail.Types.LaunchPattern) input.ReadEnum();
            break;
          }
          case 37: {
            Delay = input.ReadFloat();
            break;
          }
          case 40: {
            TurretTrack = input.ReadBool();
            break;
          }
          case 50: {
            if (flightProfile_ == null) {
              FlightProfile = new global::IUX.FlightProfile();
            }
            input.ReadMessage(FlightProfile);
            break;
          }
          case 58: {
            if (target_ == null) {
              Target = new global::IUX.Location();
            }
            input.ReadMessage(Target);
            break;
          }
          case 64: {
            InterceptTime = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LaunchRail message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///*
      /// Launch pattern enumerator for specifiying what method to use for launch a missile or multiple missiles
      /// </summary>
      public enum LaunchPattern {
        /// <summary>
        /// Launch a single specified missile
        /// </summary>
        [pbr::OriginalName("NORMAL")] Normal = 0,
        /// <summary>
        /// Launch all the currently armed missiles in sequence (one after the other)
        /// </summary>
        [pbr::OriginalName("ARMED_SEQUENTIAL")] ArmedSequential = 1,
        /// <summary>
        /// Launch all the currently armed missiles at the same time
        /// </summary>
        [pbr::OriginalName("ARMED_SIMULTANEOUS")] ArmedSimultaneous = 2,
        /// <summary>
        /// Launch all the armed missiles after a certain delay (Like simultaneous, but with a delay before launching)
        /// </summary>
        [pbr::OriginalName("ARMED_DELAY")] ArmedDelay = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///*
  /// Turret output message for indicating missile has benn loaded onto a rail.  
  /// Curretly unused (Carryover from IUX v4.0)
  /// </summary>
  public sealed partial class MissileLoaded : pb::IMessage<MissileLoaded>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MissileLoaded> _parser = new pb::MessageParser<MissileLoaded>(() => new MissileLoaded());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MissileLoaded> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileLoaded() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileLoaded(MissileLoaded other) : this() {
      baseStationId_ = other.baseStationId_;
      rail_ = other.rail_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileLoaded Clone() {
      return new MissileLoaded(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 2;
    private uint rail_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { return rail_; }
      set {
        rail_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MissileLoaded);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MissileLoaded other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Rail != other.Rail) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Rail != 0) hash ^= Rail.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Rail != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MissileLoaded other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Rail != 0) {
        Rail = other.Rail;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret output message for indicating missile has been removed from a rail.  
  /// Curretly unused (Carryover from IUX v4.0)
  /// </summary>
  public sealed partial class MissileUnloaded : pb::IMessage<MissileUnloaded>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MissileUnloaded> _parser = new pb::MessageParser<MissileUnloaded>(() => new MissileUnloaded());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MissileUnloaded> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileUnloaded() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileUnloaded(MissileUnloaded other) : this() {
      baseStationId_ = other.baseStationId_;
      rail_ = other.rail_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MissileUnloaded Clone() {
      return new MissileUnloaded(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 2;
    private uint rail_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { return rail_; }
      set {
        rail_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MissileUnloaded);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MissileUnloaded other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (Rail != other.Rail) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (Rail != 0) hash ^= Rail.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (Rail != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Rail);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (Rail != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MissileUnloaded other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.Rail != 0) {
        Rail = other.Rail;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            Rail = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Turret control message for resetting a BSC and/or the attached missiles.  
  /// This message is intended to be sent by the ASSURE terminal in cases where a software reset is needed.
  /// This _Should __Not___ be necessary for production software, the underlying bugs should be fixed. Primarily
  /// intended for testing and debugging.
  ///
  /// This message can reset various aspects of the system, as specified in the
  /// [ResetMode](#IUX.TurretReset.ResetMode) enumerator.
  /// </summary>
  public sealed partial class TurretReset : pb::IMessage<TurretReset>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TurretReset> _parser = new pb::MessageParser<TurretReset>(() => new TurretReset());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TurretReset> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretReset() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretReset(TurretReset other) : this() {
      _hasBits0 = other._hasBits0;
      baseStationId_ = other.baseStationId_;
      resetMode_ = other.resetMode_;
      rail_ = other.rail_;
      bank_ = other.bank_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TurretReset Clone() {
      return new TurretReset(this);
    }

    /// <summary>Field number for the "base_station_id" field.</summary>
    public const int BaseStationIdFieldNumber = 1;
    private uint baseStationId_;
    /// <summary>
    /// The ID of the target BSC. This is checked on the BSC to make sure the message was intended for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BaseStationId {
      get { return baseStationId_; }
      set {
        baseStationId_ = value;
      }
    }

    /// <summary>Field number for the "reset_mode" field.</summary>
    public const int ResetModeFieldNumber = 2;
    private global::IUX.TurretReset.Types.ResetMode resetMode_ = global::IUX.TurretReset.Types.ResetMode.All;
    /// <summary>
    /// The reset mode to use on the BSC
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.TurretReset.Types.ResetMode ResetMode {
      get { return resetMode_; }
      set {
        resetMode_ = value;
      }
    }

    /// <summary>Field number for the "rail" field.</summary>
    public const int RailFieldNumber = 3;
    private uint rail_;
    /// <summary>
    /// If resetting a rail, use this to specify the rail to reset
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Rail {
      get { if ((_hasBits0 & 1) != 0) { return rail_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        rail_ = value;
      }
    }
    /// <summary>Gets whether the "rail" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRail {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "rail" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRail() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "bank" field.</summary>
    public const int BankFieldNumber = 4;
    private uint bank_;
    /// <summary>
    /// If resetting a bank, use this to specify the bank to reset
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Bank {
      get { if ((_hasBits0 & 2) != 0) { return bank_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        bank_ = value;
      }
    }
    /// <summary>Gets whether the "bank" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBank {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "bank" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBank() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TurretReset);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TurretReset other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseStationId != other.BaseStationId) return false;
      if (ResetMode != other.ResetMode) return false;
      if (Rail != other.Rail) return false;
      if (Bank != other.Bank) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseStationId != 0) hash ^= BaseStationId.GetHashCode();
      if (ResetMode != global::IUX.TurretReset.Types.ResetMode.All) hash ^= ResetMode.GetHashCode();
      if (HasRail) hash ^= Rail.GetHashCode();
      if (HasBank) hash ^= Bank.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (ResetMode != global::IUX.TurretReset.Types.ResetMode.All) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ResetMode);
      }
      if (HasRail) {
        output.WriteRawTag(24);
        output.WriteUInt32(Rail);
      }
      if (HasBank) {
        output.WriteRawTag(32);
        output.WriteUInt32(Bank);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BaseStationId != 0) {
        output.WriteRawTag(13);
        output.WriteFixed32(BaseStationId);
      }
      if (ResetMode != global::IUX.TurretReset.Types.ResetMode.All) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ResetMode);
      }
      if (HasRail) {
        output.WriteRawTag(24);
        output.WriteUInt32(Rail);
      }
      if (HasBank) {
        output.WriteRawTag(32);
        output.WriteUInt32(Bank);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseStationId != 0) {
        size += 1 + 4;
      }
      if (ResetMode != global::IUX.TurretReset.Types.ResetMode.All) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResetMode);
      }
      if (HasRail) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Rail);
      }
      if (HasBank) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Bank);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TurretReset other) {
      if (other == null) {
        return;
      }
      if (other.BaseStationId != 0) {
        BaseStationId = other.BaseStationId;
      }
      if (other.ResetMode != global::IUX.TurretReset.Types.ResetMode.All) {
        ResetMode = other.ResetMode;
      }
      if (other.HasRail) {
        Rail = other.Rail;
      }
      if (other.HasBank) {
        Bank = other.Bank;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            ResetMode = (global::IUX.TurretReset.Types.ResetMode) input.ReadEnum();
            break;
          }
          case 24: {
            Rail = input.ReadUInt32();
            break;
          }
          case 32: {
            Bank = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BaseStationId = input.ReadFixed32();
            break;
          }
          case 16: {
            ResetMode = (global::IUX.TurretReset.Types.ResetMode) input.ReadEnum();
            break;
          }
          case 24: {
            Rail = input.ReadUInt32();
            break;
          }
          case 32: {
            Bank = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TurretReset message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///*
      /// Reset Mode enumerator for possible reset types
      /// </summary>
      public enum ResetMode {
        /// <summary>
        /// Reset all the missile attached to the BSC (rails and banks)
        /// </summary>
        [pbr::OriginalName("ALL")] All = 0,
        /// <summary>
        /// Reset the specified rail only
        /// </summary>
        [pbr::OriginalName("RAIL")] Rail = 1,
        /// <summary>
        /// Reset the specified bank of missiles
        /// </summary>
        [pbr::OriginalName("BANK")] Bank = 2,
        /// <summary>
        /// Reset the radio transmitters (Current not implemented, Usage unclear)
        /// </summary>
        [pbr::OriginalName("RF915")] Rf915 = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///*
  /// BSS Control message for requesting a ballistic solution via [BSSReply](#IUX.BSSReply) message.  
  /// This message is intended for various systems (BSC, ASSURE) to request ballistic solutions
  /// for a known target and missile location. This message contains the data and the boolean
  /// request parameters for the BSS to provide the desired solution data.
  /// 
  /// All fields default to 0 ([protobuf standard](https://developers.google.com/protocol-buffers/docs/proto3#default)).
  /// </summary>
  public sealed partial class BSSRequest : pb::IMessage<BSSRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BSSRequest> _parser = new pb::MessageParser<BSSRequest>(() => new BSSRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BSSRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSRequest(BSSRequest other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      basePosition_ = other.basePosition_ != null ? other.basePosition_.Clone() : null;
      baseVelocity_ = other.baseVelocity_ != null ? other.baseVelocity_.Clone() : null;
      baseAcceleration_ = other.baseAcceleration_ != null ? other.baseAcceleration_.Clone() : null;
      targetPosition_ = other.targetPosition_ != null ? other.targetPosition_.Clone() : null;
      targetVelocity_ = other.targetVelocity_ != null ? other.targetVelocity_.Clone() : null;
      targetAcceleration_ = other.targetAcceleration_ != null ? other.targetAcceleration_.Clone() : null;
      flightTime_ = other.flightTime_;
      getStatus_ = other.getStatus_;
      getInterceptENU_ = other.getInterceptENU_;
      getInterceptECEF_ = other.getInterceptECEF_;
      getInterceptGEO_ = other.getInterceptGEO_;
      getLaunchAngles_ = other.getLaunchAngles_;
      returnAddress_ = other.returnAddress_;
      returnPort_ = other.returnPort_;
      replyWithTurretTrack_ = other.replyWithTurretTrack_;
      turretTrackDownstreamAddress_ = other.turretTrackDownstreamAddress_;
      missileBlockConfig_ = other.missileBlockConfig_;
      getMissilePositionENU_ = other.getMissilePositionENU_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSRequest Clone() {
      return new BSSRequest(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    /// <summary>
    /// Incremental request ID (Provided by the sender). Should be incremented for each message sent (or 0 when it isnt needed). This value is used to ensure a [BSSReply](#IUX.BSSReply) was the reply to a specific [BSSRequest](#IUX.BSSRequest).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "base_position" field.</summary>
    public const int BasePositionFieldNumber = 2;
    private global::IUX.Point3 basePosition_;
    /// <summary>
    /// The X,Y,Z ECEF location of the Turret/Launch-Base
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 BasePosition {
      get { return basePosition_; }
      set {
        basePosition_ = value;
      }
    }

    /// <summary>Field number for the "base_velocity" field.</summary>
    public const int BaseVelocityFieldNumber = 3;
    private global::IUX.Point3 baseVelocity_;
    /// <summary>
    /// The X,Y,Z ECEF velocity of the Turret/Launch-Base
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 BaseVelocity {
      get { return baseVelocity_; }
      set {
        baseVelocity_ = value;
      }
    }

    /// <summary>Field number for the "base_acceleration" field.</summary>
    public const int BaseAccelerationFieldNumber = 4;
    private global::IUX.Point3 baseAcceleration_;
    /// <summary>
    /// The X,Y,Z ECEF acceleration of the Turret/Launch-Base
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 BaseAcceleration {
      get { return baseAcceleration_; }
      set {
        baseAcceleration_ = value;
      }
    }

    /// <summary>Field number for the "target_position" field.</summary>
    public const int TargetPositionFieldNumber = 5;
    private global::IUX.Point3 targetPosition_;
    /// <summary>
    /// The X,Y,Z ECEF location of the Target
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 TargetPosition {
      get { return targetPosition_; }
      set {
        targetPosition_ = value;
      }
    }

    /// <summary>Field number for the "target_velocity" field.</summary>
    public const int TargetVelocityFieldNumber = 6;
    private global::IUX.Point3 targetVelocity_;
    /// <summary>
    /// The X,Y,Z ECEF velocity of the Target
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 TargetVelocity {
      get { return targetVelocity_; }
      set {
        targetVelocity_ = value;
      }
    }

    /// <summary>Field number for the "target_acceleration" field.</summary>
    public const int TargetAccelerationFieldNumber = 7;
    private global::IUX.Point3 targetAcceleration_;
    /// <summary>
    /// The X,Y,Z ECEF acceleration of the Target
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 TargetAcceleration {
      get { return targetAcceleration_; }
      set {
        targetAcceleration_ = value;
      }
    }

    /// <summary>Field number for the "flight_time" field.</summary>
    public const int FlightTimeFieldNumber = 8;
    private float flightTime_;
    /// <summary>
    /// The current time of flight. Used for calculating remaining time of flight. Leave as 0 for pre-flight calculations
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float FlightTime {
      get { return flightTime_; }
      set {
        flightTime_ = value;
      }
    }

    /// <summary>Field number for the "get_status" field.</summary>
    public const int GetStatusFieldNumber = 9;
    private bool getStatus_;
    /// <summary>
    /// Request the BSS status. If this is the only value requested, All the above data will be ignored and a [BSSReply](#IUX.BSSReply) will be sent with just the BSS status data included.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetStatus {
      get { return getStatus_; }
      set {
        getStatus_ = value;
      }
    }

    /// <summary>Field number for the "get_intercept_ENU" field.</summary>
    public const int GetInterceptENUFieldNumber = 10;
    private bool getInterceptENU_;
    /// <summary>
    /// Request the intercept location as an ENU coordinate relative to the provided base_position.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetInterceptENU {
      get { return getInterceptENU_; }
      set {
        getInterceptENU_ = value;
      }
    }

    /// <summary>Field number for the "get_intercept_ECEF" field.</summary>
    public const int GetInterceptECEFFieldNumber = 11;
    private bool getInterceptECEF_;
    /// <summary>
    /// Request the absolute intercept location as an ECEF coordinate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetInterceptECEF {
      get { return getInterceptECEF_; }
      set {
        getInterceptECEF_ = value;
      }
    }

    /// <summary>Field number for the "get_intercept_GEO" field.</summary>
    public const int GetInterceptGEOFieldNumber = 12;
    private bool getInterceptGEO_;
    /// <summary>
    /// Request the absolute intercept location as Geodetic Lat/Lon/Alt coordinate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetInterceptGEO {
      get { return getInterceptGEO_; }
      set {
        getInterceptGEO_ = value;
      }
    }

    /// <summary>Field number for the "get_launch_angles" field.</summary>
    public const int GetLaunchAnglesFieldNumber = 13;
    private bool getLaunchAngles_;
    /// <summary>
    /// Request the launch angle data for launch of ballistic missile (Both azimuth and elevation)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetLaunchAngles {
      get { return getLaunchAngles_; }
      set {
        getLaunchAngles_ = value;
      }
    }

    /// <summary>Field number for the "return_address" field.</summary>
    public const int ReturnAddressFieldNumber = 14;
    private uint returnAddress_;
    /// <summary>
    /// Specify the address to send the BSS reply to. Used in cases where the [BSSReply](#IUX.BSSReply) or [TurretTrack](#IUX.TurretTrack) message should be send back to another address. If not specified, sends to the same IP as it received from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ReturnAddress {
      get { return returnAddress_; }
      set {
        returnAddress_ = value;
      }
    }

    /// <summary>Field number for the "return_port" field.</summary>
    public const int ReturnPortFieldNumber = 15;
    private uint returnPort_;
    /// <summary>
    /// Specify the port to send the reply to. (Same idea as return_address). If not specified, sends to the same port as it received from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ReturnPort {
      get { return returnPort_; }
      set {
        returnPort_ = value;
      }
    }

    /// <summary>Field number for the "reply_with_turret_track" field.</summary>
    public const int ReplyWithTurretTrackFieldNumber = 16;
    private bool replyWithTurretTrack_;
    /// <summary>
    /// This boolean is to force the BSS to reply with [TurretTrack](#IUX.TurretTrack) message. The [TurretTrack](#IUX.TurretTrack) message will contain an [AzElT2](#IUX.AzElT2) style target location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReplyWithTurretTrack {
      get { return replyWithTurretTrack_; }
      set {
        replyWithTurretTrack_ = value;
      }
    }

    /// <summary>Field number for the "turret_track_downstream_address" field.</summary>
    public const int TurretTrackDownstreamAddressFieldNumber = 17;
    private uint turretTrackDownstreamAddress_;
    /// <summary>
    /// If reply_with_turret_track is specified, this is the ID of the downstream device expecting to recieve the [TurretTrack](#IUX.TurretTrack) message. Needed for BSC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TurretTrackDownstreamAddress {
      get { if ((_hasBits0 & 1) != 0) { return turretTrackDownstreamAddress_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        turretTrackDownstreamAddress_ = value;
      }
    }
    /// <summary>Gets whether the "turret_track_downstream_address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTurretTrackDownstreamAddress {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "turret_track_downstream_address" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTurretTrackDownstreamAddress() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "missile_block_config" field.</summary>
    public const int MissileBlockConfigFieldNumber = 18;
    private global::IUX.BlockConfig missileBlockConfig_ = global::IUX.BlockConfig.Noblock;
    /// <summary>
    /// The missile Block config to calculate an intercept for. If not specified (defaults to NOBLOCK), the BSS may calculate with a default Block, or may not return a solution in the [BSSReply](#IUX.BSSReply)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.BlockConfig MissileBlockConfig {
      get { return missileBlockConfig_; }
      set {
        missileBlockConfig_ = value;
      }
    }

    /// <summary>Field number for the "get_missile_position_ENU" field.</summary>
    public const int GetMissilePositionENUFieldNumber = 19;
    private bool getMissilePositionENU_;
    /// <summary>
    /// Request the estimated position of the missile at t = flight_time as an ENU coordinate relative to the provided base_position.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool GetMissilePositionENU {
      get { return getMissilePositionENU_; }
      set {
        getMissilePositionENU_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BSSRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BSSRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!object.Equals(BasePosition, other.BasePosition)) return false;
      if (!object.Equals(BaseVelocity, other.BaseVelocity)) return false;
      if (!object.Equals(BaseAcceleration, other.BaseAcceleration)) return false;
      if (!object.Equals(TargetPosition, other.TargetPosition)) return false;
      if (!object.Equals(TargetVelocity, other.TargetVelocity)) return false;
      if (!object.Equals(TargetAcceleration, other.TargetAcceleration)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FlightTime, other.FlightTime)) return false;
      if (GetStatus != other.GetStatus) return false;
      if (GetInterceptENU != other.GetInterceptENU) return false;
      if (GetInterceptECEF != other.GetInterceptECEF) return false;
      if (GetInterceptGEO != other.GetInterceptGEO) return false;
      if (GetLaunchAngles != other.GetLaunchAngles) return false;
      if (ReturnAddress != other.ReturnAddress) return false;
      if (ReturnPort != other.ReturnPort) return false;
      if (ReplyWithTurretTrack != other.ReplyWithTurretTrack) return false;
      if (TurretTrackDownstreamAddress != other.TurretTrackDownstreamAddress) return false;
      if (MissileBlockConfig != other.MissileBlockConfig) return false;
      if (GetMissilePositionENU != other.GetMissilePositionENU) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0) hash ^= Id.GetHashCode();
      if (basePosition_ != null) hash ^= BasePosition.GetHashCode();
      if (baseVelocity_ != null) hash ^= BaseVelocity.GetHashCode();
      if (baseAcceleration_ != null) hash ^= BaseAcceleration.GetHashCode();
      if (targetPosition_ != null) hash ^= TargetPosition.GetHashCode();
      if (targetVelocity_ != null) hash ^= TargetVelocity.GetHashCode();
      if (targetAcceleration_ != null) hash ^= TargetAcceleration.GetHashCode();
      if (FlightTime != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FlightTime);
      if (GetStatus != false) hash ^= GetStatus.GetHashCode();
      if (GetInterceptENU != false) hash ^= GetInterceptENU.GetHashCode();
      if (GetInterceptECEF != false) hash ^= GetInterceptECEF.GetHashCode();
      if (GetInterceptGEO != false) hash ^= GetInterceptGEO.GetHashCode();
      if (GetLaunchAngles != false) hash ^= GetLaunchAngles.GetHashCode();
      if (ReturnAddress != 0) hash ^= ReturnAddress.GetHashCode();
      if (ReturnPort != 0) hash ^= ReturnPort.GetHashCode();
      if (ReplyWithTurretTrack != false) hash ^= ReplyWithTurretTrack.GetHashCode();
      if (HasTurretTrackDownstreamAddress) hash ^= TurretTrackDownstreamAddress.GetHashCode();
      if (MissileBlockConfig != global::IUX.BlockConfig.Noblock) hash ^= MissileBlockConfig.GetHashCode();
      if (GetMissilePositionENU != false) hash ^= GetMissilePositionENU.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (basePosition_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BasePosition);
      }
      if (baseVelocity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(BaseVelocity);
      }
      if (baseAcceleration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BaseAcceleration);
      }
      if (targetPosition_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(TargetPosition);
      }
      if (targetVelocity_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TargetVelocity);
      }
      if (targetAcceleration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(TargetAcceleration);
      }
      if (FlightTime != 0F) {
        output.WriteRawTag(69);
        output.WriteFloat(FlightTime);
      }
      if (GetStatus != false) {
        output.WriteRawTag(72);
        output.WriteBool(GetStatus);
      }
      if (GetInterceptENU != false) {
        output.WriteRawTag(80);
        output.WriteBool(GetInterceptENU);
      }
      if (GetInterceptECEF != false) {
        output.WriteRawTag(88);
        output.WriteBool(GetInterceptECEF);
      }
      if (GetInterceptGEO != false) {
        output.WriteRawTag(96);
        output.WriteBool(GetInterceptGEO);
      }
      if (GetLaunchAngles != false) {
        output.WriteRawTag(104);
        output.WriteBool(GetLaunchAngles);
      }
      if (ReturnAddress != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(ReturnAddress);
      }
      if (ReturnPort != 0) {
        output.WriteRawTag(120);
        output.WriteUInt32(ReturnPort);
      }
      if (ReplyWithTurretTrack != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(ReplyWithTurretTrack);
      }
      if (HasTurretTrackDownstreamAddress) {
        output.WriteRawTag(141, 1);
        output.WriteFixed32(TurretTrackDownstreamAddress);
      }
      if (MissileBlockConfig != global::IUX.BlockConfig.Noblock) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) MissileBlockConfig);
      }
      if (GetMissilePositionENU != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(GetMissilePositionENU);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (basePosition_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BasePosition);
      }
      if (baseVelocity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(BaseVelocity);
      }
      if (baseAcceleration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BaseAcceleration);
      }
      if (targetPosition_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(TargetPosition);
      }
      if (targetVelocity_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TargetVelocity);
      }
      if (targetAcceleration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(TargetAcceleration);
      }
      if (FlightTime != 0F) {
        output.WriteRawTag(69);
        output.WriteFloat(FlightTime);
      }
      if (GetStatus != false) {
        output.WriteRawTag(72);
        output.WriteBool(GetStatus);
      }
      if (GetInterceptENU != false) {
        output.WriteRawTag(80);
        output.WriteBool(GetInterceptENU);
      }
      if (GetInterceptECEF != false) {
        output.WriteRawTag(88);
        output.WriteBool(GetInterceptECEF);
      }
      if (GetInterceptGEO != false) {
        output.WriteRawTag(96);
        output.WriteBool(GetInterceptGEO);
      }
      if (GetLaunchAngles != false) {
        output.WriteRawTag(104);
        output.WriteBool(GetLaunchAngles);
      }
      if (ReturnAddress != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(ReturnAddress);
      }
      if (ReturnPort != 0) {
        output.WriteRawTag(120);
        output.WriteUInt32(ReturnPort);
      }
      if (ReplyWithTurretTrack != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(ReplyWithTurretTrack);
      }
      if (HasTurretTrackDownstreamAddress) {
        output.WriteRawTag(141, 1);
        output.WriteFixed32(TurretTrackDownstreamAddress);
      }
      if (MissileBlockConfig != global::IUX.BlockConfig.Noblock) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) MissileBlockConfig);
      }
      if (GetMissilePositionENU != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(GetMissilePositionENU);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (basePosition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BasePosition);
      }
      if (baseVelocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseVelocity);
      }
      if (baseAcceleration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseAcceleration);
      }
      if (targetPosition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TargetPosition);
      }
      if (targetVelocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TargetVelocity);
      }
      if (targetAcceleration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TargetAcceleration);
      }
      if (FlightTime != 0F) {
        size += 1 + 4;
      }
      if (GetStatus != false) {
        size += 1 + 1;
      }
      if (GetInterceptENU != false) {
        size += 1 + 1;
      }
      if (GetInterceptECEF != false) {
        size += 1 + 1;
      }
      if (GetInterceptGEO != false) {
        size += 1 + 1;
      }
      if (GetLaunchAngles != false) {
        size += 1 + 1;
      }
      if (ReturnAddress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReturnAddress);
      }
      if (ReturnPort != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReturnPort);
      }
      if (ReplyWithTurretTrack != false) {
        size += 2 + 1;
      }
      if (HasTurretTrackDownstreamAddress) {
        size += 2 + 4;
      }
      if (MissileBlockConfig != global::IUX.BlockConfig.Noblock) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) MissileBlockConfig);
      }
      if (GetMissilePositionENU != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BSSRequest other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0) {
        Id = other.Id;
      }
      if (other.basePosition_ != null) {
        if (basePosition_ == null) {
          BasePosition = new global::IUX.Point3();
        }
        BasePosition.MergeFrom(other.BasePosition);
      }
      if (other.baseVelocity_ != null) {
        if (baseVelocity_ == null) {
          BaseVelocity = new global::IUX.Point3();
        }
        BaseVelocity.MergeFrom(other.BaseVelocity);
      }
      if (other.baseAcceleration_ != null) {
        if (baseAcceleration_ == null) {
          BaseAcceleration = new global::IUX.Point3();
        }
        BaseAcceleration.MergeFrom(other.BaseAcceleration);
      }
      if (other.targetPosition_ != null) {
        if (targetPosition_ == null) {
          TargetPosition = new global::IUX.Point3();
        }
        TargetPosition.MergeFrom(other.TargetPosition);
      }
      if (other.targetVelocity_ != null) {
        if (targetVelocity_ == null) {
          TargetVelocity = new global::IUX.Point3();
        }
        TargetVelocity.MergeFrom(other.TargetVelocity);
      }
      if (other.targetAcceleration_ != null) {
        if (targetAcceleration_ == null) {
          TargetAcceleration = new global::IUX.Point3();
        }
        TargetAcceleration.MergeFrom(other.TargetAcceleration);
      }
      if (other.FlightTime != 0F) {
        FlightTime = other.FlightTime;
      }
      if (other.GetStatus != false) {
        GetStatus = other.GetStatus;
      }
      if (other.GetInterceptENU != false) {
        GetInterceptENU = other.GetInterceptENU;
      }
      if (other.GetInterceptECEF != false) {
        GetInterceptECEF = other.GetInterceptECEF;
      }
      if (other.GetInterceptGEO != false) {
        GetInterceptGEO = other.GetInterceptGEO;
      }
      if (other.GetLaunchAngles != false) {
        GetLaunchAngles = other.GetLaunchAngles;
      }
      if (other.ReturnAddress != 0) {
        ReturnAddress = other.ReturnAddress;
      }
      if (other.ReturnPort != 0) {
        ReturnPort = other.ReturnPort;
      }
      if (other.ReplyWithTurretTrack != false) {
        ReplyWithTurretTrack = other.ReplyWithTurretTrack;
      }
      if (other.HasTurretTrackDownstreamAddress) {
        TurretTrackDownstreamAddress = other.TurretTrackDownstreamAddress;
      }
      if (other.MissileBlockConfig != global::IUX.BlockConfig.Noblock) {
        MissileBlockConfig = other.MissileBlockConfig;
      }
      if (other.GetMissilePositionENU != false) {
        GetMissilePositionENU = other.GetMissilePositionENU;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (basePosition_ == null) {
              BasePosition = new global::IUX.Point3();
            }
            input.ReadMessage(BasePosition);
            break;
          }
          case 26: {
            if (baseVelocity_ == null) {
              BaseVelocity = new global::IUX.Point3();
            }
            input.ReadMessage(BaseVelocity);
            break;
          }
          case 34: {
            if (baseAcceleration_ == null) {
              BaseAcceleration = new global::IUX.Point3();
            }
            input.ReadMessage(BaseAcceleration);
            break;
          }
          case 42: {
            if (targetPosition_ == null) {
              TargetPosition = new global::IUX.Point3();
            }
            input.ReadMessage(TargetPosition);
            break;
          }
          case 50: {
            if (targetVelocity_ == null) {
              TargetVelocity = new global::IUX.Point3();
            }
            input.ReadMessage(TargetVelocity);
            break;
          }
          case 58: {
            if (targetAcceleration_ == null) {
              TargetAcceleration = new global::IUX.Point3();
            }
            input.ReadMessage(TargetAcceleration);
            break;
          }
          case 69: {
            FlightTime = input.ReadFloat();
            break;
          }
          case 72: {
            GetStatus = input.ReadBool();
            break;
          }
          case 80: {
            GetInterceptENU = input.ReadBool();
            break;
          }
          case 88: {
            GetInterceptECEF = input.ReadBool();
            break;
          }
          case 96: {
            GetInterceptGEO = input.ReadBool();
            break;
          }
          case 104: {
            GetLaunchAngles = input.ReadBool();
            break;
          }
          case 112: {
            ReturnAddress = input.ReadUInt32();
            break;
          }
          case 120: {
            ReturnPort = input.ReadUInt32();
            break;
          }
          case 128: {
            ReplyWithTurretTrack = input.ReadBool();
            break;
          }
          case 141: {
            TurretTrackDownstreamAddress = input.ReadFixed32();
            break;
          }
          case 144: {
            MissileBlockConfig = (global::IUX.BlockConfig) input.ReadEnum();
            break;
          }
          case 152: {
            GetMissilePositionENU = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (basePosition_ == null) {
              BasePosition = new global::IUX.Point3();
            }
            input.ReadMessage(BasePosition);
            break;
          }
          case 26: {
            if (baseVelocity_ == null) {
              BaseVelocity = new global::IUX.Point3();
            }
            input.ReadMessage(BaseVelocity);
            break;
          }
          case 34: {
            if (baseAcceleration_ == null) {
              BaseAcceleration = new global::IUX.Point3();
            }
            input.ReadMessage(BaseAcceleration);
            break;
          }
          case 42: {
            if (targetPosition_ == null) {
              TargetPosition = new global::IUX.Point3();
            }
            input.ReadMessage(TargetPosition);
            break;
          }
          case 50: {
            if (targetVelocity_ == null) {
              TargetVelocity = new global::IUX.Point3();
            }
            input.ReadMessage(TargetVelocity);
            break;
          }
          case 58: {
            if (targetAcceleration_ == null) {
              TargetAcceleration = new global::IUX.Point3();
            }
            input.ReadMessage(TargetAcceleration);
            break;
          }
          case 69: {
            FlightTime = input.ReadFloat();
            break;
          }
          case 72: {
            GetStatus = input.ReadBool();
            break;
          }
          case 80: {
            GetInterceptENU = input.ReadBool();
            break;
          }
          case 88: {
            GetInterceptECEF = input.ReadBool();
            break;
          }
          case 96: {
            GetInterceptGEO = input.ReadBool();
            break;
          }
          case 104: {
            GetLaunchAngles = input.ReadBool();
            break;
          }
          case 112: {
            ReturnAddress = input.ReadUInt32();
            break;
          }
          case 120: {
            ReturnPort = input.ReadUInt32();
            break;
          }
          case 128: {
            ReplyWithTurretTrack = input.ReadBool();
            break;
          }
          case 141: {
            TurretTrackDownstreamAddress = input.ReadFixed32();
            break;
          }
          case 144: {
            MissileBlockConfig = (global::IUX.BlockConfig) input.ReadEnum();
            break;
          }
          case 152: {
            GetMissilePositionENU = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///* 
  /// BSS reply message. Return message of a [BSSRequest](#IUX.BSSRequest).  
  /// This message carries a lot of optional data, as requested in the [BSSRequest](#IUX.BSSRequest).
  /// While data is expected to be received as requested, the existance of values should always be
  /// checked before reading. This reduces the likelyhood of accidentally reading null data as real data.
  /// </summary>
  public sealed partial class BSSReply : pb::IMessage<BSSReply>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BSSReply> _parser = new pb::MessageParser<BSSReply>(() => new BSSReply());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BSSReply> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::IUX.IUXSubmessagesReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSReply() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSReply(BSSReply other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      status_ = other.status_;
      interceptENU_ = other.interceptENU_ != null ? other.interceptENU_.Clone() : null;
      interceptECEF_ = other.interceptECEF_ != null ? other.interceptECEF_.Clone() : null;
      interceptLat_ = other.interceptLat_;
      interceptLon_ = other.interceptLon_;
      interceptAlt_ = other.interceptAlt_;
      timeToIntercept_ = other.timeToIntercept_;
      launchElevation_ = other.launchElevation_;
      launchAzimuth_ = other.launchAzimuth_;
      missilePositionENU_ = other.missilePositionENU_ != null ? other.missilePositionENU_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BSSReply Clone() {
      return new BSSReply(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    /// <summary>
    /// Request ID, matching the one specified in the [BSSRequest](#IUX.BSSRequest)] id field. Used for Request-Reply matching.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private global::IUX.StatusCode status_;
    /// <summary>
    /// The BSS status. Generally included anyway. If explicitly needed, should be explicity request. Requested using get_status in [BSSRequest](#IUX.BSSRequest)].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.StatusCode Status {
      get { if ((_hasBits0 & 1) != 0) { return status_; } else { return global::IUX.StatusCode.Nostatus; } }
      set {
        _hasBits0 |= 1;
        status_ = value;
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatus {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatus() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "intercept_ENU" field.</summary>
    public const int InterceptENUFieldNumber = 3;
    private global::IUX.Point3 interceptENU_;
    /// <summary>
    /// The ENU intercept location, using the base_position specified. Requested using get_intercept_ENU in [BSSRequest](#IUX.BSSRequest)].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 InterceptENU {
      get { return interceptENU_; }
      set {
        interceptENU_ = value;
      }
    }

    /// <summary>Field number for the "intercept_ECEF" field.</summary>
    public const int InterceptECEFFieldNumber = 4;
    private global::IUX.Point3 interceptECEF_;
    /// <summary>
    /// The ECEF absolute intercept location. Requested by get_intercept_ECEF in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 InterceptECEF {
      get { return interceptECEF_; }
      set {
        interceptECEF_ = value;
      }
    }

    /// <summary>Field number for the "intercept_lat" field.</summary>
    public const int InterceptLatFieldNumber = 5;
    private float interceptLat_;
    /// <summary>
    /// The Intercept Latitude. Requested by get_intercept_GEO in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InterceptLat {
      get { if ((_hasBits0 & 2) != 0) { return interceptLat_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        interceptLat_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_lat" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptLat {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "intercept_lat" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptLat() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "intercept_lon" field.</summary>
    public const int InterceptLonFieldNumber = 6;
    private float interceptLon_;
    /// <summary>
    /// The Intercept Longitude. Requested by get_intercept_GEO in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InterceptLon {
      get { if ((_hasBits0 & 4) != 0) { return interceptLon_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        interceptLon_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_lon" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptLon {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "intercept_lon" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptLon() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "intercept_alt" field.</summary>
    public const int InterceptAltFieldNumber = 7;
    private float interceptAlt_;
    /// <summary>
    /// The Intercept Altitude. Requested by get_intercept_GEO in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InterceptAlt {
      get { if ((_hasBits0 & 8) != 0) { return interceptAlt_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        interceptAlt_ = value;
      }
    }
    /// <summary>Gets whether the "intercept_alt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterceptAlt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "intercept_alt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterceptAlt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "time_to_intercept" field.</summary>
    public const int TimeToInterceptFieldNumber = 8;
    private float timeToIntercept_;
    /// <summary>
    /// The T2I (time to intercept) calculated by Jack Bishop's ballistics code. Value in seconds. Requested by any get_intercept_XXX in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TimeToIntercept {
      get { if ((_hasBits0 & 16) != 0) { return timeToIntercept_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        timeToIntercept_ = value;
      }
    }
    /// <summary>Gets whether the "time_to_intercept" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTimeToIntercept {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "time_to_intercept" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTimeToIntercept() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "launch_elevation" field.</summary>
    public const int LaunchElevationFieldNumber = 9;
    private float launchElevation_;
    /// <summary>
    /// The ENU Elevation Launch Angle for the Turret. Requested by get_launch_angles in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LaunchElevation {
      get { if ((_hasBits0 & 32) != 0) { return launchElevation_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        launchElevation_ = value;
      }
    }
    /// <summary>Gets whether the "launch_elevation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLaunchElevation {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "launch_elevation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLaunchElevation() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "launch_azimuth" field.</summary>
    public const int LaunchAzimuthFieldNumber = 10;
    private float launchAzimuth_;
    /// <summary>
    /// The ENU Azimuth Launch Angle for the Turret. Requested by get_launch_angles in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LaunchAzimuth {
      get { if ((_hasBits0 & 64) != 0) { return launchAzimuth_; } else { return 0F; } }
      set {
        _hasBits0 |= 64;
        launchAzimuth_ = value;
      }
    }
    /// <summary>Gets whether the "launch_azimuth" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLaunchAzimuth {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "launch_azimuth" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLaunchAzimuth() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "missile_position_ENU" field.</summary>
    public const int MissilePositionENUFieldNumber = 11;
    private global::IUX.Point3 missilePositionENU_;
    /// <summary>
    /// The estimated ENU position of the missile at t = flight_time. Requested by get_missile_position_ENU in [BSSRequest](#IUX.BSSRequest)] 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::IUX.Point3 MissilePositionENU {
      get { return missilePositionENU_; }
      set {
        missilePositionENU_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BSSReply);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BSSReply other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(InterceptENU, other.InterceptENU)) return false;
      if (!object.Equals(InterceptECEF, other.InterceptECEF)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterceptLat, other.InterceptLat)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterceptLon, other.InterceptLon)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterceptAlt, other.InterceptAlt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TimeToIntercept, other.TimeToIntercept)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LaunchElevation, other.LaunchElevation)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LaunchAzimuth, other.LaunchAzimuth)) return false;
      if (!object.Equals(MissilePositionENU, other.MissilePositionENU)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0) hash ^= Id.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (interceptENU_ != null) hash ^= InterceptENU.GetHashCode();
      if (interceptECEF_ != null) hash ^= InterceptECEF.GetHashCode();
      if (HasInterceptLat) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterceptLat);
      if (HasInterceptLon) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterceptLon);
      if (HasInterceptAlt) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterceptAlt);
      if (HasTimeToIntercept) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TimeToIntercept);
      if (HasLaunchElevation) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LaunchElevation);
      if (HasLaunchAzimuth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LaunchAzimuth);
      if (missilePositionENU_ != null) hash ^= MissilePositionENU.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Status);
      }
      if (interceptENU_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(InterceptENU);
      }
      if (interceptECEF_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InterceptECEF);
      }
      if (HasInterceptLat) {
        output.WriteRawTag(45);
        output.WriteFloat(InterceptLat);
      }
      if (HasInterceptLon) {
        output.WriteRawTag(53);
        output.WriteFloat(InterceptLon);
      }
      if (HasInterceptAlt) {
        output.WriteRawTag(61);
        output.WriteFloat(InterceptAlt);
      }
      if (HasTimeToIntercept) {
        output.WriteRawTag(69);
        output.WriteFloat(TimeToIntercept);
      }
      if (HasLaunchElevation) {
        output.WriteRawTag(77);
        output.WriteFloat(LaunchElevation);
      }
      if (HasLaunchAzimuth) {
        output.WriteRawTag(85);
        output.WriteFloat(LaunchAzimuth);
      }
      if (missilePositionENU_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(MissilePositionENU);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Id != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Status);
      }
      if (interceptENU_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(InterceptENU);
      }
      if (interceptECEF_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InterceptECEF);
      }
      if (HasInterceptLat) {
        output.WriteRawTag(45);
        output.WriteFloat(InterceptLat);
      }
      if (HasInterceptLon) {
        output.WriteRawTag(53);
        output.WriteFloat(InterceptLon);
      }
      if (HasInterceptAlt) {
        output.WriteRawTag(61);
        output.WriteFloat(InterceptAlt);
      }
      if (HasTimeToIntercept) {
        output.WriteRawTag(69);
        output.WriteFloat(TimeToIntercept);
      }
      if (HasLaunchElevation) {
        output.WriteRawTag(77);
        output.WriteFloat(LaunchElevation);
      }
      if (HasLaunchAzimuth) {
        output.WriteRawTag(85);
        output.WriteFloat(LaunchAzimuth);
      }
      if (missilePositionENU_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(MissilePositionENU);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (interceptENU_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InterceptENU);
      }
      if (interceptECEF_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InterceptECEF);
      }
      if (HasInterceptLat) {
        size += 1 + 4;
      }
      if (HasInterceptLon) {
        size += 1 + 4;
      }
      if (HasInterceptAlt) {
        size += 1 + 4;
      }
      if (HasTimeToIntercept) {
        size += 1 + 4;
      }
      if (HasLaunchElevation) {
        size += 1 + 4;
      }
      if (HasLaunchAzimuth) {
        size += 1 + 4;
      }
      if (missilePositionENU_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MissilePositionENU);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BSSReply other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0) {
        Id = other.Id;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.interceptENU_ != null) {
        if (interceptENU_ == null) {
          InterceptENU = new global::IUX.Point3();
        }
        InterceptENU.MergeFrom(other.InterceptENU);
      }
      if (other.interceptECEF_ != null) {
        if (interceptECEF_ == null) {
          InterceptECEF = new global::IUX.Point3();
        }
        InterceptECEF.MergeFrom(other.InterceptECEF);
      }
      if (other.HasInterceptLat) {
        InterceptLat = other.InterceptLat;
      }
      if (other.HasInterceptLon) {
        InterceptLon = other.InterceptLon;
      }
      if (other.HasInterceptAlt) {
        InterceptAlt = other.InterceptAlt;
      }
      if (other.HasTimeToIntercept) {
        TimeToIntercept = other.TimeToIntercept;
      }
      if (other.HasLaunchElevation) {
        LaunchElevation = other.LaunchElevation;
      }
      if (other.HasLaunchAzimuth) {
        LaunchAzimuth = other.LaunchAzimuth;
      }
      if (other.missilePositionENU_ != null) {
        if (missilePositionENU_ == null) {
          MissilePositionENU = new global::IUX.Point3();
        }
        MissilePositionENU.MergeFrom(other.MissilePositionENU);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Status = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 26: {
            if (interceptENU_ == null) {
              InterceptENU = new global::IUX.Point3();
            }
            input.ReadMessage(InterceptENU);
            break;
          }
          case 34: {
            if (interceptECEF_ == null) {
              InterceptECEF = new global::IUX.Point3();
            }
            input.ReadMessage(InterceptECEF);
            break;
          }
          case 45: {
            InterceptLat = input.ReadFloat();
            break;
          }
          case 53: {
            InterceptLon = input.ReadFloat();
            break;
          }
          case 61: {
            InterceptAlt = input.ReadFloat();
            break;
          }
          case 69: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 77: {
            LaunchElevation = input.ReadFloat();
            break;
          }
          case 85: {
            LaunchAzimuth = input.ReadFloat();
            break;
          }
          case 90: {
            if (missilePositionENU_ == null) {
              MissilePositionENU = new global::IUX.Point3();
            }
            input.ReadMessage(MissilePositionENU);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Status = (global::IUX.StatusCode) input.ReadEnum();
            break;
          }
          case 26: {
            if (interceptENU_ == null) {
              InterceptENU = new global::IUX.Point3();
            }
            input.ReadMessage(InterceptENU);
            break;
          }
          case 34: {
            if (interceptECEF_ == null) {
              InterceptECEF = new global::IUX.Point3();
            }
            input.ReadMessage(InterceptECEF);
            break;
          }
          case 45: {
            InterceptLat = input.ReadFloat();
            break;
          }
          case 53: {
            InterceptLon = input.ReadFloat();
            break;
          }
          case 61: {
            InterceptAlt = input.ReadFloat();
            break;
          }
          case 69: {
            TimeToIntercept = input.ReadFloat();
            break;
          }
          case 77: {
            LaunchElevation = input.ReadFloat();
            break;
          }
          case 85: {
            LaunchAzimuth = input.ReadFloat();
            break;
          }
          case 90: {
            if (missilePositionENU_ == null) {
              MissilePositionENU = new global::IUX.Point3();
            }
            input.ReadMessage(MissilePositionENU);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
